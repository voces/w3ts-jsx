// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`works 1`] = `
"
local ____modules = {}
local ____moduleCache = {}
local ____originalRequire = require
local function require(file)
    if ____moduleCache[file] then
        return ____moduleCache[file]
    end
    if ____modules[file] then
        ____moduleCache[file] = ____modules[file]()
        return ____moduleCache[file]
    else
        if ____originalRequire then
            return ____originalRequire(file)
        else
            error(\\"module '\\" .. file .. \\"' not found\\")
        end
    end
end
____modules = {
[\\"lualib_bundle\\"] = function() function __TS__ArrayConcat(arr1, ...)
    local args = {...}
    local out = {}
    for ____, val in ipairs(arr1) do
        out[#out + 1] = val
    end
    for ____, arg in ipairs(args) do
        if pcall(
            function() return #arg end
        ) and (type(arg) ~= \\"string\\") then
            local argAsArray = arg
            for ____, val in ipairs(argAsArray) do
                out[#out + 1] = val
            end
        else
            out[#out + 1] = arg
        end
    end
    return out
end

function __TS__ArrayEvery(arr, callbackfn)
    do
        local i = 0
        while i < #arr do
            if not callbackfn(_G, arr[i + 1], i, arr) then
                return false
            end
            i = i + 1
        end
    end
    return true
end

function __TS__ArrayFilter(arr, callbackfn)
    local result = {}
    do
        local i = 0
        while i < #arr do
            if callbackfn(_G, arr[i + 1], i, arr) then
                result[#result + 1] = arr[i + 1]
            end
            i = i + 1
        end
    end
    return result
end

function __TS__ArrayForEach(arr, callbackFn)
    do
        local i = 0
        while i < #arr do
            callbackFn(_G, arr[i + 1], i, arr)
            i = i + 1
        end
    end
end

function __TS__ArrayFind(arr, predicate)
    local len = #arr
    local k = 0
    while k < len do
        local elem = arr[k + 1]
        if predicate(_G, elem, k, arr) then
            return elem
        end
        k = k + 1
    end
    return nil
end

function __TS__ArrayFindIndex(arr, callbackFn)
    do
        local i = 0
        local len = #arr
        while i < len do
            if callbackFn(_G, arr[i + 1], i, arr) then
                return i
            end
            i = i + 1
        end
    end
    return -1
end

function __TS__ArrayIncludes(self, searchElement, fromIndex)
    if fromIndex == nil then
        fromIndex = 0
    end
    local len = #self
    local k = fromIndex
    if fromIndex < 0 then
        k = len + fromIndex
    end
    if k < 0 then
        k = 0
    end
    for i = k, len do
        if self[i + 1] == searchElement then
            return true
        end
    end
    return false
end

function __TS__ArrayIndexOf(arr, searchElement, fromIndex)
    local len = #arr
    if len == 0 then
        return -1
    end
    local n = 0
    if fromIndex then
        n = fromIndex
    end
    if n >= len then
        return -1
    end
    local k
    if n >= 0 then
        k = n
    else
        k = len + n
        if k < 0 then
            k = 0
        end
    end
    do
        local i = k
        while i < len do
            if arr[i + 1] == searchElement then
                return i
            end
            i = i + 1
        end
    end
    return -1
end

function __TS__ArrayJoin(self, separator)
    if separator == nil then
        separator = \\",\\"
    end
    local result = \\"\\"
    for index, value in ipairs(self) do
        if index > 1 then
            result = tostring(result) .. tostring(separator)
        end
        result = tostring(result) .. tostring(
            tostring(value)
        )
    end
    return result
end

function __TS__ArrayMap(arr, callbackfn)
    local newArray = {}
    do
        local i = 0
        while i < #arr do
            newArray[i + 1] = callbackfn(_G, arr[i + 1], i, arr)
            i = i + 1
        end
    end
    return newArray
end

function __TS__ArrayPush(arr, ...)
    local items = {...}
    for ____, item in ipairs(items) do
        arr[#arr + 1] = item
    end
    return #arr
end

function __TS__ArrayReduce(arr, callbackFn, ...)
    local len = #arr
    local k = 0
    local accumulator = nil
    if select(\\"#\\", ...) ~= 0 then
        accumulator = select(1, ...)
    elseif len > 0 then
        accumulator = arr[1]
        k = 1
    else
        error(\\"Reduce of empty array with no initial value\\", 0)
    end
    for i = k, len - 1 do
        accumulator = callbackFn(_G, accumulator, arr[i + 1], i, arr)
    end
    return accumulator
end

function __TS__ArrayReduceRight(arr, callbackFn, ...)
    local len = #arr
    local k = len - 1
    local accumulator = nil
    if select(\\"#\\", ...) ~= 0 then
        accumulator = select(1, ...)
    elseif len > 0 then
        accumulator = arr[k + 1]
        k = k - 1
    else
        error(\\"Reduce of empty array with no initial value\\", 0)
    end
    for i = k, 0, -1 do
        accumulator = callbackFn(_G, accumulator, arr[i + 1], i, arr)
    end
    return accumulator
end

function __TS__ArrayReverse(arr)
    local i = 0
    local j = #arr - 1
    while i < j do
        local temp = arr[j + 1]
        arr[j + 1] = arr[i + 1]
        arr[i + 1] = temp
        i = i + 1
        j = j - 1
    end
    return arr
end

function __TS__ArrayShift(arr)
    return table.remove(arr, 1)
end

function __TS__ArrayUnshift(arr, ...)
    local items = {...}
    do
        local i = #items - 1
        while i >= 0 do
            table.insert(arr, 1, items[i + 1])
            i = i - 1
        end
    end
    return #arr
end

function __TS__ArraySort(arr, compareFn)
    if compareFn ~= nil then
        table.sort(
            arr,
            function(a, b) return compareFn(_G, a, b) < 0 end
        )
    else
        table.sort(arr)
    end
    return arr
end

function __TS__ArraySlice(list, first, last)
    local len = #list
    local relativeStart = first or 0
    local k
    if relativeStart < 0 then
        k = math.max(len + relativeStart, 0)
    else
        k = math.min(relativeStart, len)
    end
    local relativeEnd = last
    if last == nil then
        relativeEnd = len
    end
    local final
    if relativeEnd < 0 then
        final = math.max(len + relativeEnd, 0)
    else
        final = math.min(relativeEnd, len)
    end
    local out = {}
    local n = 0
    while k < final do
        out[n + 1] = list[k + 1]
        k = k + 1
        n = n + 1
    end
    return out
end

function __TS__ArraySome(arr, callbackfn)
    do
        local i = 0
        while i < #arr do
            if callbackfn(_G, arr[i + 1], i, arr) then
                return true
            end
            i = i + 1
        end
    end
    return false
end

function __TS__ArraySplice(list, ...)
    local len = #list
    local actualArgumentCount = select(\\"#\\", ...)
    local start = select(1, ...)
    local deleteCount = select(2, ...)
    local actualStart
    if start < 0 then
        actualStart = math.max(len + start, 0)
    else
        actualStart = math.min(start, len)
    end
    local itemCount = math.max(actualArgumentCount - 2, 0)
    local actualDeleteCount
    if actualArgumentCount == 0 then
        actualDeleteCount = 0
    elseif actualArgumentCount == 1 then
        actualDeleteCount = len - actualStart
    else
        actualDeleteCount = math.min(
            math.max(deleteCount or 0, 0),
            len - actualStart
        )
    end
    local out = {}
    do
        local k = 0
        while k < actualDeleteCount do
            local from = actualStart + k
            if list[from + 1] then
                out[k + 1] = list[from + 1]
            end
            k = k + 1
        end
    end
    if itemCount < actualDeleteCount then
        do
            local k = actualStart
            while k < (len - actualDeleteCount) do
                local from = k + actualDeleteCount
                local to = k + itemCount
                if list[from + 1] then
                    list[to + 1] = list[from + 1]
                else
                    list[to + 1] = nil
                end
                k = k + 1
            end
        end
        do
            local k = len
            while k > ((len - actualDeleteCount) + itemCount) do
                list[k] = nil
                k = k - 1
            end
        end
    elseif itemCount > actualDeleteCount then
        do
            local k = len - actualDeleteCount
            while k > actualStart do
                local from = (k + actualDeleteCount) - 1
                local to = (k + itemCount) - 1
                if list[from + 1] then
                    list[to + 1] = list[from + 1]
                else
                    list[to + 1] = nil
                end
                k = k - 1
            end
        end
    end
    local j = actualStart
    for i = 3, actualArgumentCount do
        list[j + 1] = select(i, ...)
        j = j + 1
    end
    do
        local k = #list - 1
        while k >= ((len - actualDeleteCount) + itemCount) do
            list[k + 1] = nil
            k = k - 1
        end
    end
    return out
end

function __TS__ArrayToObject(array)
    local object = {}
    do
        local i = 0
        while i < #array do
            object[i] = array[i + 1]
            i = i + 1
        end
    end
    return object
end

function __TS__ArrayFlat(array, depth)
    if depth == nil then
        depth = 1
    end
    local result = {}
    for ____, value in ipairs(array) do
        if ((depth > 0) and (type(value) == \\"table\\")) and ((value[1] ~= nil) or (next(value, nil) == nil)) then
            result = __TS__ArrayConcat(
                result,
                __TS__ArrayFlat(value, depth - 1)
            )
        else
            result[#result + 1] = value
        end
    end
    return result
end

function __TS__ArrayFlatMap(array, callback)
    local result = {}
    do
        local i = 0
        while i < #array do
            local value = callback(_G, array[i + 1], i, array)
            if (type(value) == \\"table\\") and ((value[1] ~= nil) or (next(value, nil) == nil)) then
                result = __TS__ArrayConcat(result, value)
            else
                result[#result + 1] = value
            end
            i = i + 1
        end
    end
    return result
end

function __TS__ArraySetLength(arr, length)
    if (((length < 0) or (length ~= length)) or (length == math.huge)) or (math.floor(length) ~= length) then
        error(
            \\"invalid array length: \\" .. tostring(length),
            0
        )
    end
    do
        local i = #arr - 1
        while i >= length do
            arr[i + 1] = nil
            i = i - 1
        end
    end
    return length
end

function __TS__Class(self)
    local c = {prototype = {}}
    c.prototype.__index = c.prototype
    c.prototype.constructor = c
    return c
end

function __TS__ClassExtends(target, base)
    target.____super = base
    local staticMetatable = setmetatable({__index = base}, base)
    setmetatable(target, staticMetatable)
    local baseMetatable = getmetatable(base)
    if baseMetatable then
        if type(baseMetatable.__index) == \\"function\\" then
            staticMetatable.__index = baseMetatable.__index
        end
        if type(baseMetatable.__newindex) == \\"function\\" then
            staticMetatable.__newindex = baseMetatable.__newindex
        end
    end
    setmetatable(target.prototype, base.prototype)
    if type(base.prototype.__index) == \\"function\\" then
        target.prototype.__index = base.prototype.__index
    end
    if type(base.prototype.__newindex) == \\"function\\" then
        target.prototype.__newindex = base.prototype.__newindex
    end
    if type(base.prototype.__tostring) == \\"function\\" then
        target.prototype.__tostring = base.prototype.__tostring
    end
end

function __TS__Decorate(decorators, target, key, desc)
    local result = target
    do
        local i = #decorators
        while i >= 0 do
            local decorator = decorators[i + 1]
            if decorator then
                local oldResult = result
                if key == nil then
                    result = decorator(_G, result)
                elseif desc ~= nil then
                    result = decorator(_G, target, key, result)
                else
                    result = decorator(_G, target, key)
                end
                result = result or oldResult
            end
            i = i - 1
        end
    end
    return result
end

function ____descriptorIndex(self, key)
    local value = rawget(self, key)
    if value ~= nil then
        return value
    end
    local metatable = getmetatable(self)
    while metatable do
        local rawResult = rawget(metatable, key)
        if rawResult ~= nil then
            return rawResult
        end
        local descriptors = rawget(metatable, \\"_descriptors\\")
        if descriptors then
            local descriptor = descriptors[key]
            if descriptor then
                if descriptor.get then
                    return descriptor.get(self)
                end
                return
            end
        end
        metatable = getmetatable(metatable)
    end
end
function ____descriptorNewindex(self, key, value)
    local metatable = getmetatable(self)
    while metatable do
        local descriptors = rawget(metatable, \\"_descriptors\\")
        if descriptors then
            local descriptor = descriptors[key]
            if descriptor then
                if descriptor.set then
                    descriptor.set(self, value)
                end
                return
            end
        end
        metatable = getmetatable(metatable)
    end
    rawset(self, key, value)
end
function __TS__SetDescriptor(metatable, prop, descriptor)
    if not rawget(metatable, \\"_descriptors\\") then
        metatable._descriptors = {}
    end
    metatable._descriptors[prop] = descriptor
    if descriptor.get then
        metatable.__index = ____descriptorIndex
    end
    if descriptor.set then
        metatable.__newindex = ____descriptorNewindex
    end
end
function __TS__ObjectDefineProperty(object, prop, descriptor)
    local metatable = getmetatable(object)
    if not metatable then
        metatable = {}
        setmetatable(object, metatable)
    end
    __TS__SetDescriptor(metatable, prop, descriptor)
    return object
end

function __TS__New(target, ...)
    local instance = setmetatable({}, target.prototype)
    instance:____constructor(...)
    return instance
end

function __TS__GetErrorStack(self, constructor)
    local level = 1
    while true do
        local info = debug.getinfo(level, \\"f\\")
        level = level + 1
        if not info then
            level = 1
            break
        elseif info.func == constructor then
            break
        end
    end
    return debug.traceback(nil, level)
end
function __TS__WrapErrorToString(self, getDescription)
    return function(self)
        local description = getDescription(self)
        local caller = debug.getinfo(3, \\"f\\")
        if (_VERSION == \\"Lua 5.1\\") or (caller and (caller.func ~= error)) then
            return description
        else
            return (tostring(description) .. \\"\\\\n\\") .. tostring(self.stack)
        end
    end
end
function __TS__InitErrorClass(self, Type, name)
    Type.name = name
    return setmetatable(
        Type,
        {
            __call = function(____, _self, message) return __TS__New(Type, message) end
        }
    )
end
Error = __TS__InitErrorClass(
    _G,
    (function()
        local ____ = __TS__Class()
        ____.name = \\"\\"
        function ____.prototype.____constructor(self, message)
            if message == nil then
                message = \\"\\"
            end
            self.message = message
            self.name = \\"Error\\"
            self.stack = __TS__GetErrorStack(_G, self.constructor.new)
            local metatable = getmetatable(self)
            if not metatable.__errorToStringPatched then
                metatable.__errorToStringPatched = true
                metatable.__tostring = __TS__WrapErrorToString(_G, metatable.__tostring)
            end
        end
        function ____.prototype.__tostring(self)
            return (((self.message ~= \\"\\") and (function() return (tostring(self.name) .. \\": \\") .. tostring(self.message) end)) or (function() return self.name end))()
        end
        return ____
    end)(),
    \\"Error\\"
)
for ____, errorName in ipairs({\\"RangeError\\", \\"ReferenceError\\", \\"SyntaxError\\", \\"TypeError\\", \\"URIError\\"}) do
    _G[errorName] = __TS__InitErrorClass(
        _G,
        (function()
            local ____ = __TS__Class()
            ____.name = ____.name
            __TS__ClassExtends(____, Error)
            function ____.prototype.____constructor(self, ...)
                Error.prototype.____constructor(self, ...)
                self.name = errorName
            end
            return ____
        end)(),
        errorName
    )
end

__TS__Unpack = table.unpack or unpack

function __TS__FunctionBind(fn, thisArg, ...)
    local boundArgs = {...}
    return function(____, ...)
        local args = {...}
        do
            local i = 0
            while i < #boundArgs do
                table.insert(args, i + 1, boundArgs[i + 1])
                i = i + 1
            end
        end
        return fn(
            thisArg,
            __TS__Unpack(args)
        )
    end
end

____symbolMetatable = {
    __tostring = function(self)
        return (\\"Symbol(\\" .. tostring(self.description or \\"\\")) .. \\")\\"
    end
}
function __TS__Symbol(description)
    return setmetatable({description = description}, ____symbolMetatable)
end
Symbol = {
    iterator = __TS__Symbol(\\"Symbol.iterator\\"),
    hasInstance = __TS__Symbol(\\"Symbol.hasInstance\\"),
    species = __TS__Symbol(\\"Symbol.species\\"),
    toStringTag = __TS__Symbol(\\"Symbol.toStringTag\\")
}

function __TS__GeneratorIterator(self)
    return self
end
function __TS__GeneratorNext(self, ...)
    local co = self.____coroutine
    if coroutine.status(co) == \\"dead\\" then
        return {done = true}
    end
    local status, value = coroutine.resume(co, ...)
    if not status then
        error(value, 0)
    end
    return {
        value = value,
        done = coroutine.status(co) == \\"dead\\"
    }
end
function __TS__Generator(fn)
    return function(...)
        local args = {...}
        local argsLength = select(\\"#\\", ...)
        return {
            ____coroutine = coroutine.create(
                function() return fn(
                    (unpack or table.unpack)(args, 1, argsLength)
                ) end
            ),
            [Symbol.iterator] = __TS__GeneratorIterator,
            next = __TS__GeneratorNext
        }
    end
end

function __TS__InstanceOf(obj, classTbl)
    if type(classTbl) ~= \\"table\\" then
        error(\\"Right-hand side of 'instanceof' is not an object\\", 0)
    end
    if classTbl[Symbol.hasInstance] ~= nil then
        return not (not classTbl[Symbol.hasInstance](classTbl, obj))
    end
    if type(obj) == \\"table\\" then
        local luaClass = obj.constructor
        while luaClass ~= nil do
            if luaClass == classTbl then
                return true
            end
            luaClass = luaClass.____super
        end
    end
    return false
end

function __TS__InstanceOfObject(value)
    local valueType = type(value)
    return (valueType == \\"table\\") or (valueType == \\"function\\")
end

function __TS__IteratorGeneratorStep(self)
    local co = self.____coroutine
    local status, value = coroutine.resume(co)
    if not status then
        error(value, 0)
    end
    if coroutine.status(co) == \\"dead\\" then
        return
    end
    return true, value
end
function __TS__IteratorIteratorStep(self)
    local result = self:next()
    if result.done then
        return
    end
    return true, result.value
end
function __TS__IteratorStringStep(self, index)
    index = index + 1
    if index > #self then
        return
    end
    return index, string.sub(self, index, index)
end
function __TS__Iterator(iterable)
    if iterable.____coroutine ~= nil then
        return __TS__IteratorGeneratorStep, iterable
    elseif iterable[Symbol.iterator] then
        local iterator = iterable[Symbol.iterator](iterable)
        return __TS__IteratorIteratorStep, iterator
    elseif type(iterable) == \\"string\\" then
        return __TS__IteratorStringStep, iterable, 0
    else
        return ipairs(iterable)
    end
end

Map = (function()
    local Map = __TS__Class()
    Map.name = \\"Map\\"
    function Map.prototype.____constructor(self, entries)
        self[Symbol.toStringTag] = \\"Map\\"
        self.items = {}
        self.size = 0
        self.nextKey = {}
        self.previousKey = {}
        if entries == nil then
            return
        end
        local iterable = entries
        if iterable[Symbol.iterator] then
            local iterator = iterable[Symbol.iterator](iterable)
            while true do
                local result = iterator:next()
                if result.done then
                    break
                end
                local value = result.value
                self:set(value[1], value[2])
            end
        else
            local array = entries
            for ____, kvp in ipairs(array) do
                self:set(kvp[1], kvp[2])
            end
        end
    end
    function Map.prototype.clear(self)
        self.items = {}
        self.nextKey = {}
        self.previousKey = {}
        self.firstKey = nil
        self.lastKey = nil
        self.size = 0
    end
    function Map.prototype.delete(self, key)
        local contains = self:has(key)
        if contains then
            self.size = self.size - 1
            local next = self.nextKey[key]
            local previous = self.previousKey[key]
            if next and previous then
                self.nextKey[previous] = next
                self.previousKey[next] = previous
            elseif next then
                self.firstKey = next
                self.previousKey[next] = nil
            elseif previous then
                self.lastKey = previous
                self.nextKey[previous] = nil
            else
                self.firstKey = nil
                self.lastKey = nil
            end
            self.nextKey[key] = nil
            self.previousKey[key] = nil
        end
        self.items[key] = nil
        return contains
    end
    function Map.prototype.forEach(self, callback)
        for ____, key in __TS__Iterator(
            self:keys()
        ) do
            callback(_G, self.items[key], key, self)
        end
    end
    function Map.prototype.get(self, key)
        return self.items[key]
    end
    function Map.prototype.has(self, key)
        return (self.nextKey[key] ~= nil) or (self.lastKey == key)
    end
    function Map.prototype.set(self, key, value)
        local isNewValue = not self:has(key)
        if isNewValue then
            self.size = self.size + 1
        end
        self.items[key] = value
        if self.firstKey == nil then
            self.firstKey = key
            self.lastKey = key
        elseif isNewValue then
            self.nextKey[self.lastKey] = key
            self.previousKey[key] = self.lastKey
            self.lastKey = key
        end
        return self
    end
    Map.prototype[Symbol.iterator] = function(self)
        return self:entries()
    end
    function Map.prototype.entries(self)
        local ____ = self
        local items = ____.items
        local nextKey = ____.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = {key, items[key]}}
                key = nextKey[key]
                return result
            end
        }
    end
    function Map.prototype.keys(self)
        local nextKey = self.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = key}
                key = nextKey[key]
                return result
            end
        }
    end
    function Map.prototype.values(self)
        local ____ = self
        local items = ____.items
        local nextKey = ____.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = items[key]}
                key = nextKey[key]
                return result
            end
        }
    end
    Map[Symbol.species] = Map
    return Map
end)()

__TS__MathAtan2 = math.atan2 or math.atan

function __TS__Number(value)
    local valueType = type(value)
    if valueType == \\"number\\" then
        return value
    elseif valueType == \\"string\\" then
        local numberValue = tonumber(value)
        if numberValue then
            return numberValue
        end
        if value == \\"Infinity\\" then
            return math.huge
        end
        if value == \\"-Infinity\\" then
            return -math.huge
        end
        local stringWithoutSpaces = string.gsub(value, \\"%s\\", \\"\\")
        if stringWithoutSpaces == \\"\\" then
            return 0
        end
        return 0 / 0
    elseif valueType == \\"boolean\\" then
        return (value and 1) or 0
    else
        return 0 / 0
    end
end

function __TS__NumberIsFinite(value)
    return (((type(value) == \\"number\\") and (value == value)) and (value ~= math.huge)) and (value ~= -math.huge)
end

function __TS__NumberIsNaN(value)
    return value ~= value
end

____radixChars = \\"0123456789abcdefghijklmnopqrstuvwxyz\\"
function __TS__NumberToString(self, radix)
    if ((((radix == nil) or (radix == 10)) or (self == math.huge)) or (self == -math.huge)) or (self ~= self) then
        return tostring(self)
    end
    radix = math.floor(radix)
    if (radix < 2) or (radix > 36) then
        error(\\"toString() radix argument must be between 2 and 36\\", 0)
    end
    local integer, fraction = math.modf(
        math.abs(self)
    )
    local result = \\"\\"
    if radix == 8 then
        result = string.format(\\"%o\\", integer)
    elseif radix == 16 then
        result = string.format(\\"%x\\", integer)
    else
        repeat
            do
                result = tostring(
                    __TS__StringAccess(____radixChars, integer % radix)
                ) .. tostring(result)
                integer = math.floor(integer / radix)
            end
        until not (integer ~= 0)
    end
    if fraction ~= 0 then
        result = tostring(result) .. \\".\\"
        local delta = 1e-16
        repeat
            do
                fraction = fraction * radix
                delta = delta * radix
                local digit = math.floor(fraction)
                result = tostring(result) .. tostring(
                    __TS__StringAccess(____radixChars, digit)
                )
                fraction = fraction - digit
            end
        until not (fraction >= delta)
    end
    if self < 0 then
        result = \\"-\\" .. tostring(result)
    end
    return result
end

function __TS__ObjectAssign(to, ...)
    local sources = {...}
    if to == nil then
        return to
    end
    for ____, source in ipairs(sources) do
        for key in pairs(source) do
            to[key] = source[key]
        end
    end
    return to
end

function __TS__ObjectEntries(obj)
    local result = {}
    for key in pairs(obj) do
        result[#result + 1] = {key, obj[key]}
    end
    return result
end

function __TS__ObjectFromEntries(entries)
    local obj = {}
    local iterable = entries
    if iterable[Symbol.iterator] then
        local iterator = iterable[Symbol.iterator](iterable)
        while true do
            local result = iterator:next()
            if result.done then
                break
            end
            local value = result.value
            obj[value[1]] = value[2]
        end
    else
        for ____, entry in ipairs(entries) do
            obj[entry[1]] = entry[2]
        end
    end
    return obj
end

function __TS__ObjectKeys(obj)
    local result = {}
    for key in pairs(obj) do
        result[#result + 1] = key
    end
    return result
end

function __TS__ObjectRest(target, usedProperties)
    local result = {}
    for property in pairs(target) do
        if not usedProperties[property] then
            result[property] = target[property]
        end
    end
    return result
end

function __TS__ObjectValues(obj)
    local result = {}
    for key in pairs(obj) do
        result[#result + 1] = obj[key]
    end
    return result
end

Set = (function()
    local Set = __TS__Class()
    Set.name = \\"Set\\"
    function Set.prototype.____constructor(self, values)
        self[Symbol.toStringTag] = \\"Set\\"
        self.size = 0
        self.nextKey = {}
        self.previousKey = {}
        if values == nil then
            return
        end
        local iterable = values
        if iterable[Symbol.iterator] then
            local iterator = iterable[Symbol.iterator](iterable)
            while true do
                local result = iterator:next()
                if result.done then
                    break
                end
                self:add(result.value)
            end
        else
            local array = values
            for ____, value in ipairs(array) do
                self:add(value)
            end
        end
    end
    function Set.prototype.add(self, value)
        local isNewValue = not self:has(value)
        if isNewValue then
            self.size = self.size + 1
        end
        if self.firstKey == nil then
            self.firstKey = value
            self.lastKey = value
        elseif isNewValue then
            self.nextKey[self.lastKey] = value
            self.previousKey[value] = self.lastKey
            self.lastKey = value
        end
        return self
    end
    function Set.prototype.clear(self)
        self.nextKey = {}
        self.previousKey = {}
        self.firstKey = nil
        self.lastKey = nil
        self.size = 0
    end
    function Set.prototype.delete(self, value)
        local contains = self:has(value)
        if contains then
            self.size = self.size - 1
            local next = self.nextKey[value]
            local previous = self.previousKey[value]
            if next and previous then
                self.nextKey[previous] = next
                self.previousKey[next] = previous
            elseif next then
                self.firstKey = next
                self.previousKey[next] = nil
            elseif previous then
                self.lastKey = previous
                self.nextKey[previous] = nil
            else
                self.firstKey = nil
                self.lastKey = nil
            end
            self.nextKey[value] = nil
            self.previousKey[value] = nil
        end
        return contains
    end
    function Set.prototype.forEach(self, callback)
        for ____, key in __TS__Iterator(
            self:keys()
        ) do
            callback(_G, key, key, self)
        end
    end
    function Set.prototype.has(self, value)
        return (self.nextKey[value] ~= nil) or (self.lastKey == value)
    end
    Set.prototype[Symbol.iterator] = function(self)
        return self:values()
    end
    function Set.prototype.entries(self)
        local nextKey = self.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = {key, key}}
                key = nextKey[key]
                return result
            end
        }
    end
    function Set.prototype.keys(self)
        local nextKey = self.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = key}
                key = nextKey[key]
                return result
            end
        }
    end
    function Set.prototype.values(self)
        local nextKey = self.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = key}
                key = nextKey[key]
                return result
            end
        }
    end
    Set[Symbol.species] = Set
    return Set
end)()

WeakMap = (function()
    local WeakMap = __TS__Class()
    WeakMap.name = \\"WeakMap\\"
    function WeakMap.prototype.____constructor(self, entries)
        self[Symbol.toStringTag] = \\"WeakMap\\"
        self.items = {}
        setmetatable(self.items, {__mode = \\"k\\"})
        if entries == nil then
            return
        end
        local iterable = entries
        if iterable[Symbol.iterator] then
            local iterator = iterable[Symbol.iterator](iterable)
            while true do
                local result = iterator:next()
                if result.done then
                    break
                end
                local value = result.value
                self.items[value[1]] = value[2]
            end
        else
            for ____, kvp in ipairs(entries) do
                self.items[kvp[1]] = kvp[2]
            end
        end
    end
    function WeakMap.prototype.delete(self, key)
        local contains = self:has(key)
        self.items[key] = nil
        return contains
    end
    function WeakMap.prototype.get(self, key)
        return self.items[key]
    end
    function WeakMap.prototype.has(self, key)
        return self.items[key] ~= nil
    end
    function WeakMap.prototype.set(self, key, value)
        self.items[key] = value
        return self
    end
    WeakMap[Symbol.species] = WeakMap
    return WeakMap
end)()

WeakSet = (function()
    local WeakSet = __TS__Class()
    WeakSet.name = \\"WeakSet\\"
    function WeakSet.prototype.____constructor(self, values)
        self[Symbol.toStringTag] = \\"WeakSet\\"
        self.items = {}
        setmetatable(self.items, {__mode = \\"k\\"})
        if values == nil then
            return
        end
        local iterable = values
        if iterable[Symbol.iterator] then
            local iterator = iterable[Symbol.iterator](iterable)
            while true do
                local result = iterator:next()
                if result.done then
                    break
                end
                self.items[result.value] = true
            end
        else
            for ____, value in ipairs(values) do
                self.items[value] = true
            end
        end
    end
    function WeakSet.prototype.add(self, value)
        self.items[value] = true
        return self
    end
    function WeakSet.prototype.delete(self, value)
        local contains = self:has(value)
        self.items[value] = nil
        return contains
    end
    function WeakSet.prototype.has(self, value)
        return self.items[value] == true
    end
    WeakSet[Symbol.species] = WeakSet
    return WeakSet
end)()

function __TS__SourceMapTraceBack(fileName, sourceMap)
    _G.__TS__sourcemap = _G.__TS__sourcemap or ({})
    _G.__TS__sourcemap[fileName] = sourceMap
    if _G.__TS__originalTraceback == nil then
        _G.__TS__originalTraceback = debug.traceback
        debug.traceback = function(thread, message, level)
            local trace
            if ((thread == nil) and (message == nil)) and (level == nil) then
                trace = _G.__TS__originalTraceback()
            else
                trace = _G.__TS__originalTraceback(thread, message, level)
            end
            if type(trace) ~= \\"string\\" then
                return trace
            end
            local result = string.gsub(
                trace,
                \\"(%S+).lua:(%d+)\\",
                function(file, line)
                    local fileSourceMap = _G.__TS__sourcemap[tostring(file) .. \\".lua\\"]
                    if fileSourceMap and fileSourceMap[line] then
                        return (tostring(file) .. \\".ts:\\") .. tostring(fileSourceMap[line])
                    end
                    return (tostring(file) .. \\".lua:\\") .. tostring(line)
                end
            )
            return result
        end
    end
end

function __TS__Spread(iterable)
    local arr = {}
    if type(iterable) == \\"string\\" then
        do
            local i = 0
            while i < #iterable do
                arr[#arr + 1] = __TS__StringAccess(iterable, i)
                i = i + 1
            end
        end
    else
        for ____, item in __TS__Iterator(iterable) do
            arr[#arr + 1] = item
        end
    end
    return __TS__Unpack(arr)
end

function __TS__StringAccess(self, index)
    if (index >= 0) and (index < #self) then
        return string.sub(self, index + 1, index + 1)
    end
end

function __TS__StringCharAt(self, pos)
    if pos ~= pos then
        pos = 0
    end
    if pos < 0 then
        return \\"\\"
    end
    return string.sub(self, pos + 1, pos + 1)
end

function __TS__StringCharCodeAt(self, index)
    if index ~= index then
        index = 0
    end
    if index < 0 then
        return 0 / 0
    end
    return string.byte(self, index + 1) or (0 / 0)
end

function __TS__StringConcat(str1, ...)
    local args = {...}
    local out = str1
    for ____, arg in ipairs(args) do
        out = tostring(out) .. tostring(arg)
    end
    return out
end

function __TS__StringEndsWith(self, searchString, endPosition)
    if (endPosition == nil) or (endPosition > #self) then
        endPosition = #self
    end
    return string.sub(self, (endPosition - #searchString) + 1, endPosition) == searchString
end

function __TS__StringPadEnd(self, maxLength, fillString)
    if fillString == nil then
        fillString = \\" \\"
    end
    if maxLength ~= maxLength then
        maxLength = 0
    end
    if (maxLength == -math.huge) or (maxLength == math.huge) then
        error(\\"Invalid string length\\", 0)
    end
    if (#self >= maxLength) or (#fillString == 0) then
        return self
    end
    maxLength = maxLength - #self
    if maxLength > #fillString then
        fillString = tostring(fillString) .. tostring(
            string.rep(
                fillString,
                math.floor(maxLength / #fillString)
            )
        )
    end
    return tostring(self) .. tostring(
        string.sub(
            fillString,
            1,
            math.floor(maxLength)
        )
    )
end

function __TS__StringPadStart(self, maxLength, fillString)
    if fillString == nil then
        fillString = \\" \\"
    end
    if maxLength ~= maxLength then
        maxLength = 0
    end
    if (maxLength == -math.huge) or (maxLength == math.huge) then
        error(\\"Invalid string length\\", 0)
    end
    if (#self >= maxLength) or (#fillString == 0) then
        return self
    end
    maxLength = maxLength - #self
    if maxLength > #fillString then
        fillString = tostring(fillString) .. tostring(
            string.rep(
                fillString,
                math.floor(maxLength / #fillString)
            )
        )
    end
    return tostring(
        string.sub(
            fillString,
            1,
            math.floor(maxLength)
        )
    ) .. tostring(self)
end

function __TS__StringReplace(source, searchValue, replaceValue)
    searchValue = string.gsub(searchValue, \\"[%%%(%)%.%+%-%*%?%[%^%$]\\", \\"%%%1\\")
    if type(replaceValue) == \\"string\\" then
        replaceValue = string.gsub(replaceValue, \\"%%\\", \\"%%%%\\")
        local result = string.gsub(source, searchValue, replaceValue, 1)
        return result
    else
        local result = string.gsub(
            source,
            searchValue,
            function(match) return replaceValue(_G, match) end,
            1
        )
        return result
    end
end

function __TS__StringSlice(self, start, ____end)
    if (start == nil) or (start ~= start) then
        start = 0
    end
    if ____end ~= ____end then
        ____end = 0
    end
    if start >= 0 then
        start = start + 1
    end
    if (____end ~= nil) and (____end < 0) then
        ____end = ____end - 1
    end
    return string.sub(self, start, ____end)
end

function __TS__StringSplit(source, separator, limit)
    if limit == nil then
        limit = 4294967295
    end
    if limit == 0 then
        return {}
    end
    local out = {}
    local index = 0
    local count = 0
    if (separator == nil) or (separator == \\"\\") then
        while (index < (#source - 1)) and (count < limit) do
            out[count + 1] = __TS__StringAccess(source, index)
            count = count + 1
            index = index + 1
        end
    else
        local separatorLength = #separator
        local nextIndex = (string.find(source, separator, nil, true) or 0) - 1
        while (nextIndex >= 0) and (count < limit) do
            out[count + 1] = __TS__StringSubstring(source, index, nextIndex)
            count = count + 1
            index = nextIndex + separatorLength
            nextIndex = (string.find(
                source,
                separator,
                math.max(index + 1, 1),
                true
            ) or 0) - 1
        end
    end
    if count < limit then
        out[count + 1] = __TS__StringSubstring(source, index)
    end
    return out
end

function __TS__StringStartsWith(self, searchString, position)
    if (position == nil) or (position < 0) then
        position = 0
    end
    return string.sub(self, position + 1, #searchString + position) == searchString
end

function __TS__StringSubstr(self, from, length)
    if from ~= from then
        from = 0
    end
    if length ~= nil then
        if (length ~= length) or (length <= 0) then
            return \\"\\"
        end
        length = length + from
    end
    if from >= 0 then
        from = from + 1
    end
    return string.sub(self, from, length)
end

function __TS__StringSubstring(self, start, ____end)
    if ____end ~= ____end then
        ____end = 0
    end
    if (____end ~= nil) and (start > ____end) then
        start, ____end = __TS__Unpack({____end, start})
    end
    if start >= 0 then
        start = start + 1
    else
        start = 1
    end
    if (____end ~= nil) and (____end < 0) then
        ____end = 0
    end
    return string.sub(self, start, ____end)
end

function __TS__StringTrim(self)
    local result = string.gsub(self, \\"^[%s ﻿]*(.-)[%s ﻿]*$\\", \\"%1\\")
    return result
end

function __TS__StringTrimEnd(self)
    local result = string.gsub(self, \\"[%s ﻿]*$\\", \\"\\")
    return result
end

function __TS__StringTrimStart(self)
    local result = string.gsub(self, \\"^[%s ﻿]*\\", \\"\\")
    return result
end

____symbolRegistry = {}
function __TS__SymbolRegistryFor(key)
    if not ____symbolRegistry[key] then
        ____symbolRegistry[key] = __TS__Symbol(key)
    end
    return ____symbolRegistry[key]
end
function __TS__SymbolRegistryKeyFor(sym)
    for key in pairs(____symbolRegistry) do
        if ____symbolRegistry[key] == sym then
            return key
        end
    end
end

function __TS__TypeOf(value)
    local luaType = type(value)
    if luaType == \\"table\\" then
        return \\"object\\"
    elseif luaType == \\"nil\\" then
        return \\"undefined\\"
    else
        return luaType
    end
end

end,
[\\"node_modules.basic-pragma.src.adapter\\"] = function() local ____exports = {}
local baseCreateFrame
baseCreateFrame = function()
    error(\\"Adapter has not implemented createFrame\\", 0)
end
local baseCleanupFrame
baseCleanupFrame = function()
    error(\\"Adapter has not implemented cleanupFrame\\", 0)
end
local baseUpdateFrameProperties
baseUpdateFrameProperties = function()
    error(\\"Adapter has not implemented updateFrameProperties\\", 0)
end
local baseGetParent
baseGetParent = function()
    error(\\"Adapter has not implemented getParent\\", 0)
end
local internalAdapter = {createFrame = baseCreateFrame, cleanupFrame = baseCleanupFrame, updateFrameProperties = baseUpdateFrameProperties, getParent = baseGetParent}
____exports.adapter = internalAdapter
____exports.setAdapter = function(adapter)
    internalAdapter.createFrame = adapter.createFrame or baseCreateFrame
    internalAdapter.cleanupFrame = adapter.cleanupFrame or baseCleanupFrame
    internalAdapter.getParent = adapter.getParent or baseGetParent
    internalAdapter.updateFrameProperties = adapter.updateFrameProperties or baseUpdateFrameProperties
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.common\\"] = function() local ____exports = {}
____exports.TEXT_ELEMENT = \\"TEXT ELEMENT\\"
return ____exports
end,
[\\"node_modules.basic-pragma.src.reconciler\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____adapter = require(\\"node_modules.basic-pragma.src.adapter\\")
local adapter = ____adapter.adapter
local ____common = require(\\"node_modules.basic-pragma.src.common\\")
local TEXT_ELEMENT = ____common.TEXT_ELEMENT
local cleanupFrames, reconcileChildren, instantiate, functionalComponentClasses, isClass, createPublicInstance, updateInstance
function ____exports.reconcile(parentFrame, instance, vnode)
    do
        local ____try, err, ____returnValue = pcall(
            function()
                if not instance then
                    return true, instantiate(vnode, parentFrame)
                elseif not vnode then
                    cleanupFrames(instance)
                    return true, nil
                elseif instance.vnode.type ~= vnode.type then
                    local newInstance = instantiate(vnode, parentFrame)
                    cleanupFrames(instance)
                    return true, newInstance
                else
                    local instanceOfSameType = instance
                    if type(vnode.type) == \\"string\\" then
                        adapter:updateFrameProperties(instance.hostFrame, instance.vnode.props, vnode.props)
                        instance.childInstances = reconcileChildren(instance, vnode)
                        instanceOfSameType.vnode = vnode
                        return true, instanceOfSameType
                    elseif instanceOfSameType.publicInstance then
                        instanceOfSameType.publicInstance.props = vnode.props
                        ____exports.hooks.beforeRender(instanceOfSameType.publicInstance)
                        local childElement = instanceOfSameType.publicInstance:render(vnode.props)
                        if not childElement then
                            error(\\"Failed to render child\\", 0)
                        end
                        local oldChildInstance = instanceOfSameType.childInstance
                        local childInstance = ____exports.reconcile(parentFrame, oldChildInstance, childElement)
                        if not childInstance then
                            error(\\"Failed to update composite instance\\", 0)
                        end
                        instanceOfSameType.hostFrame = childInstance.hostFrame
                        instanceOfSameType.childInstance = childInstance
                        instanceOfSameType.vnode = vnode
                        return true, instanceOfSameType
                    else
                        error(\\"Reconciler catch all error\\", 0)
                    end
                end
                return true, nil
            end
        )
        if not ____try then
            err, ____returnValue = (function()
                print(err)
                return true, nil
            end)()
        end
        if err then
            return ____returnValue
        end
    end
end
function cleanupFrames(instance)
    if instance.childInstances then
        for ____, child in ipairs(instance.childInstances) do
            if child ~= nil then
                cleanupFrames(child)
            end
        end
    end
    if instance.childInstance then
        cleanupFrames(instance.childInstance)
    end
    adapter:cleanupFrame(instance.hostFrame)
end
function reconcileChildren(instance, vnode)
    local hostFrame = instance.hostFrame
    local childInstances = instance.childInstances
    local nextChildElements = vnode.props.children or ({})
    local newChildInstances = {}
    local count = math.max(#childInstances, #nextChildElements)
    do
        local i = 0
        while i < count do
            local childInstance = childInstances[i + 1]
            local childElement = nextChildElements[i + 1]
            local newChildInstance = ____exports.reconcile(hostFrame, childInstance, childElement)
            __TS__ArrayPush(newChildInstances, newChildInstance)
            i = i + 1
        end
    end
    return __TS__ArrayFilter(
        newChildInstances,
        function(____, instance) return instance ~= nil end
    )
end
function instantiate(vnode, parentFrame)
    local ____type = vnode.type
    local props = vnode.props
    if type(____type) == \\"string\\" then
        if ____type == TEXT_ELEMENT then
            error(\\"Cannot create inline text, yet\\", 0)
        end
        local frame = adapter:createFrame(____type, parentFrame, props)
        local childElements = props.children or ({})
        local childInstances = __TS__ArrayMap(
            childElements,
            function(____, child) return instantiate(child, frame) end
        )
        local instance = {hostFrame = frame, vnode = vnode, childInstances = childInstances, childInstance = nil}
        return instance
    else
        local instance = {}
        local publicInstance = createPublicInstance(vnode, instance)
        ____exports.hooks.beforeRender(publicInstance)
        local childElement = publicInstance:render(props)
        local childInstance = (childElement and instantiate(childElement, parentFrame)) or nil
        local hostFrame = childInstance.hostFrame
        local updateProps = {hostFrame = hostFrame, vnode = vnode, childInstance = childInstance, publicInstance = publicInstance}
        __TS__ObjectAssign(instance, updateProps)
        return instance
    end
end
function createPublicInstance(vnode, internalInstance)
    local ComponentType = vnode.type
    local props = vnode.props
    local constructor
    if type(ComponentType) == \\"string\\" then
        error(\\"Tried createPublicInstance() with string\\", 0)
    elseif isClass(ComponentType) then
        constructor = ComponentType
    else
        local renderFunc
        renderFunc = ComponentType
        local existingClass = functionalComponentClasses:get(renderFunc)
        if existingClass then
            constructor = existingClass
        else
            constructor = (function()
                local ____ = __TS__Class()
                ____.name = ____.name
                __TS__ClassExtends(____, ____exports.ClassComponent)
                function ____.prototype.render(self, props)
                    return renderFunc(props)
                end
                return ____
            end)()
            functionalComponentClasses:set(renderFunc, constructor)
        end
    end
    local publicInstance = __TS__New(constructor, props)
    publicInstance.instance = internalInstance
    return publicInstance
end
function updateInstance(internalInstance)
    local parentDom = adapter:getParent(internalInstance.hostFrame)
    local vnode = internalInstance.vnode
    if parentDom then
        ____exports.reconcile(parentDom, internalInstance, vnode)
    else
        error(\\"Tried to reconcile instance with no dom.parentDom\\", 0)
    end
end
____exports.hooks = {
    beforeRender = function(instance)
    end
}
local rootInstance = nil
function ____exports.render(vnode, container)
    local prevInstance = rootInstance
    local nextInstance = ____exports.reconcile(container, prevInstance, vnode)
    rootInstance = nextInstance
end
functionalComponentClasses = __TS__New(WeakMap)
local isLua = _G._VERSION ~= nil
isClass = function(constructor)
    if isLua then
        return type(constructor) ~= \\"function\\"
    else
        return constructor.prototype ~= nil
    end
end
local instanceMap = __TS__New(WeakMap)
____exports.ClassComponent = __TS__Class()
local ClassComponent = ____exports.ClassComponent
ClassComponent.name = \\"ClassComponent\\"
function ClassComponent.prototype.____constructor(self, props)
    self.props = props
    self.state = {}
end
__TS__SetDescriptor(
    ClassComponent.prototype,
    \\"instance\\",
    {
        set = function(self, instance)
            instanceMap:set(self, instance)
        end
    }
)
function ClassComponent.prototype.setState(self, partialState)
    self.state = __TS__ObjectAssign({}, self.state, partialState)
    local instance = instanceMap:get(self)
    if instance then
        updateInstance(instance)
    end
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.Component\\"] = function() local ____exports = {}
return ____exports
end,
[\\"node_modules.basic-pragma.src.element\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____common = require(\\"node_modules.basic-pragma.src.common\\")
local TEXT_ELEMENT = ____common.TEXT_ELEMENT
local createTextElement
function ____exports.createElement(____type, config, children)
    local ____ = __TS__ObjectAssign({}, config)
    local key = ____.key
    if key == nil then
        key = nil
    end
    local props = __TS__ObjectRest(____, {key = true, props = true})
    local flattenedChildren = __TS__ArrayMap(
        __TS__ArrayFilter(
            __TS__ArrayFlat(((children and (#children > 0)) and children) or ({})),
            function(____, c) return ((c ~= nil) and (type(c) ~= \\"boolean\\")) and ((type(c) == \\"string\\") or (not (not c.type))) end
        ),
        function(____, c) return ((type(c) == \\"string\\") and createTextElement(c)) or c end
    )
    if #flattenedChildren > 0 then
        props.children = flattenedChildren
    else
        props.children = nil
    end
    local vnode = {type = ____type, props = props}
    if key ~= nil then
        vnode.key = key
    end
    return vnode
end
function createTextElement(value)
    return ____exports.createElement(TEXT_ELEMENT, {nodeValue = value})
end
local EMPTY_OBJECT = {}
____exports.Fragment = function(props) return props.children end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.base\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____reconciler = require(\\"node_modules.basic-pragma.src.reconciler\\")
local hooks = ____reconciler.hooks
local oldBeforeRender
oldBeforeRender = hooks.beforeRender
____exports.hookContext = {}
____exports.hookMap = __TS__New(WeakMap)
hooks.beforeRender = function(instance)
    oldBeforeRender(instance)
    ____exports.hookContext.currentInstance = instance
    ____exports.hookContext.currentIndex = 0
    if not ____exports.hookMap:has(instance) then
        ____exports.hookMap:set(instance, {})
    end
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.useReducer\\"] = function() local ____exports = {}
local ____base = require(\\"node_modules.basic-pragma.src.hooks.base\\")
local hookContext = ____base.hookContext
local hookMap = ____base.hookMap
____exports.useReducer = function(reducer, initialState)
    local index = (function()
        local ____tmp = hookContext.currentIndex
        hookContext.currentIndex = ____tmp + 1
        return ____tmp
    end)()
    local hooks = hookMap:get(hookContext.currentInstance)
    local state = hooks[index + 1] or (function(o, i, v)
        o[i] = v
        return v
    end)(hooks, index + 1, {})
    state.reducer = reducer
    if not state.instance then
        state.value = {
            initialState,
            function(action)
                local nextValue = state.reducer(state.value[1], action)
                if state.value[1] ~= nextValue then
                    state.value = {nextValue, state.value[2]}
                    state.instance:setState({})
                end
            end
        }
        state.instance = hookContext.currentInstance
    end
    return state.value
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.useState\\"] = function() local ____exports = {}
local ____useReducer = require(\\"node_modules.basic-pragma.src.hooks.useReducer\\")
local useReducer = ____useReducer.useReducer
____exports.useState = function(initialState) return useReducer(
    function(_, v) return v end,
    initialState
) end
return ____exports
end,
[\\"node_modules.basic-pragma.src.index\\"] = function() local ____exports = {}
do
    local ____adapter = require(\\"node_modules.basic-pragma.src.adapter\\")
    local setAdapter = ____adapter.setAdapter
    ____exports.setAdapter = setAdapter
end
do
    local ____element = require(\\"node_modules.basic-pragma.src.element\\")
    local createElement = ____element.createElement
    local Fragment = ____element.Fragment
    ____exports.createElement = createElement
    ____exports.Fragment = Fragment
end
do
    local ____reconciler = require(\\"node_modules.basic-pragma.src.reconciler\\")
    local render = ____reconciler.render
    ____exports.render = render
end
do
    local ____useReducer = require(\\"node_modules.basic-pragma.src.hooks.useReducer\\")
    local useReducer = ____useReducer.useReducer
    ____exports.useReducer = useReducer
end
do
    local ____useState = require(\\"node_modules.basic-pragma.src.hooks.useState\\")
    local useState = ____useState.useState
    ____exports.useState = useState
end
return ____exports
end,
[\\"src.adapter\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local frameDefaults = {name = \\"AnonymousFrame\\", priority = 0, isSimple = true, typeName = nil, inherits = \\"\\", context = 0, key = nil, alpha = 255, enabled = true, font = {fileName = \\"\\", height = 16, flags = 0}, level = 0, maxLength = 9999, minMaxValue = {min = -999999999, max = 999999999}, model = {modelFile = \\"\\", cameraIndex = 0}, scale = 1, spriteAnimate = {primaryProp = 0, flags = 0}, stepSize = 0, text = \\"\\", textAlignment = {vert = TEXT_JUSTIFY_TOP, horz = TEXT_JUSTIFY_LEFT}, textColor = 16777215, texture = {texFile = \\"\\", flag = 0, blend = true}, tooltip = nil, value = 0, vertexColor = 16777215, visible = true, position = nil, absPosition = nil, size = {width = 0.1, height = 0.1}, children = nil, onClick = nil, onMouseEnter = nil, onMouseLeave = nil, onMouseUp = nil, onMouseDown = nil, onMouseWheel = nil, onCheckboxChecked = nil, onCheckboxUnchecked = nil, onEditboxTextChanged = nil, onPopupmenuItemChanged = nil, onDoubleClick = nil, onSpriteAnimUpdate = nil, onSliderChanged = nil, onDialogCancel = nil, onDialogAccept = nil, onEditboxEnter = nil}
local absurd
absurd = function(value)
    error(
        (\\"Got \\" .. tostring(value)) .. \\" when expected nothing\\",
        0
    )
end
local triggerMap = __TS__New(WeakMap)
local conditionMap = __TS__New(WeakMap)
local setEventProp
setEventProp = function(frame, event, val, oldValue)
    local t = triggerMap:get(oldValue)
    if val == nil then
        if t then
            DestroyTrigger(t)
            triggerMap:delete(oldValue)
        end
        return
    end
    if t == nil then
        t = CreateTrigger()
        BlzTriggerRegisterFrameEvent(t, frame, event)
    else
        local condition = conditionMap:get(oldValue)
        if condition then
            TriggerRemoveCondition(t, condition)
            conditionMap:delete(oldValue)
        end
    end
    local condition = TriggerAddCondition(
        t,
        Condition(
            function()
                if event == FRAMEEVENT_CONTROL_CLICK then
                    BlzFrameSetEnable(frame, false)
                    BlzFrameSetEnable(frame, true)
                end
                val()
                return false
            end
        )
    )
    conditionMap:set(val, condition)
    triggerMap:set(val, t)
end
local resolveRelative
resolveRelative = function(frame, relative)
    if type(relative) ~= \\"string\\" then
        return relative
    end
    local ____switch13 = relative
    if ____switch13 == \\"parent\\" then
        goto ____switch13_case_0
    elseif ____switch13 == \\"previous\\" then
        goto ____switch13_case_1
    end
    goto ____switch13_case_default
    ::____switch13_case_0::
    do
        return BlzFrameGetParent(frame)
    end
    ::____switch13_case_1::
    do
        do
            local parent = BlzFrameGetParent(frame)
            local children = BlzFrameGetChildrenCount(parent)
            local index = -1
            do
                local i = 0
                while i < children do
                    if BlzFrameGetChild(parent, i) == frame then
                        index = i
                        break
                    end
                    i = i + 1
                end
            end
            if index > 0 then
                return BlzFrameGetChild(parent, index - 1)
            end
            return nil
        end
    end
    ::____switch13_case_default::
    do
        absurd(relative)
    end
    ::____switch13_end::
end
local previousToParentPoint
previousToParentPoint = function(relative)
    local ____switch19 = relative
    if ____switch19 == FRAMEPOINT_RIGHT then
        goto ____switch19_case_0
    elseif ____switch19 == FRAMEPOINT_BOTTOM then
        goto ____switch19_case_1
    end
    goto ____switch19_end
    ::____switch19_case_0::
    do
        return FRAMEPOINT_LEFT
    end
    ::____switch19_case_1::
    do
        return FRAMEPOINT_TOP
    end
    ::____switch19_end::
end
local setProp
setProp = function(frame, prop, value, oldValue)
    local val = (function(____lhs)
        if ____lhs == nil then
            return frameDefaults[prop]
        else
            return ____lhs
        end
    end)(value)
    local _oldValue = oldValue
    local ____switch21 = prop
    if ____switch21 == \\"text\\" then
        goto ____switch21_case_0
    elseif ____switch21 == \\"maxLength\\" then
        goto ____switch21_case_1
    elseif ____switch21 == \\"textColor\\" then
        goto ____switch21_case_2
    elseif ____switch21 == \\"texture\\" then
        goto ____switch21_case_3
    elseif ____switch21 == \\"model\\" then
        goto ____switch21_case_4
    elseif ____switch21 == \\"alpha\\" then
        goto ____switch21_case_5
    elseif ____switch21 == \\"level\\" then
        goto ____switch21_case_6
    elseif ____switch21 == \\"visible\\" then
        goto ____switch21_case_7
    elseif ____switch21 == \\"enabled\\" then
        goto ____switch21_case_8
    elseif ____switch21 == \\"vertexColor\\" then
        goto ____switch21_case_9
    elseif ____switch21 == \\"value\\" then
        goto ____switch21_case_10
    elseif ____switch21 == \\"size\\" then
        goto ____switch21_case_11
    elseif ____switch21 == \\"stepSize\\" then
        goto ____switch21_case_12
    elseif ____switch21 == \\"tooltip\\" then
        goto ____switch21_case_13
    elseif ____switch21 == \\"font\\" then
        goto ____switch21_case_14
    elseif ____switch21 == \\"minMaxValue\\" then
        goto ____switch21_case_15
    elseif ____switch21 == \\"scale\\" then
        goto ____switch21_case_16
    elseif ____switch21 == \\"spriteAnimate\\" then
        goto ____switch21_case_17
    elseif ____switch21 == \\"textAlignment\\" then
        goto ____switch21_case_18
    elseif ____switch21 == \\"position\\" then
        goto ____switch21_case_19
    elseif ____switch21 == \\"absPosition\\" then
        goto ____switch21_case_20
    elseif ____switch21 == \\"onClick\\" then
        goto ____switch21_case_21
    elseif ____switch21 == \\"onMouseEnter\\" then
        goto ____switch21_case_22
    elseif ____switch21 == \\"onMouseLeave\\" then
        goto ____switch21_case_23
    elseif ____switch21 == \\"onMouseUp\\" then
        goto ____switch21_case_24
    elseif ____switch21 == \\"onMouseDown\\" then
        goto ____switch21_case_25
    elseif ____switch21 == \\"onMouseWheel\\" then
        goto ____switch21_case_26
    elseif ____switch21 == \\"onCheckboxChecked\\" then
        goto ____switch21_case_27
    elseif ____switch21 == \\"onCheckboxUnchecked\\" then
        goto ____switch21_case_28
    elseif ____switch21 == \\"onEditboxTextChanged\\" then
        goto ____switch21_case_29
    elseif ____switch21 == \\"onPopupmenuItemChanged\\" then
        goto ____switch21_case_30
    elseif ____switch21 == \\"onDoubleClick\\" then
        goto ____switch21_case_31
    elseif ____switch21 == \\"onSpriteAnimUpdate\\" then
        goto ____switch21_case_32
    elseif ____switch21 == \\"onSliderChanged\\" then
        goto ____switch21_case_33
    elseif ____switch21 == \\"onDialogCancel\\" then
        goto ____switch21_case_34
    elseif ____switch21 == \\"onDialogAccept\\" then
        goto ____switch21_case_35
    elseif ____switch21 == \\"onEditboxEnter\\" then
        goto ____switch21_case_36
    elseif ____switch21 == \\"name\\" then
        goto ____switch21_case_37
    elseif ____switch21 == \\"priority\\" then
        goto ____switch21_case_38
    elseif ____switch21 == \\"isSimple\\" then
        goto ____switch21_case_39
    elseif ____switch21 == \\"typeName\\" then
        goto ____switch21_case_40
    elseif ____switch21 == \\"inherits\\" then
        goto ____switch21_case_41
    elseif ____switch21 == \\"children\\" then
        goto ____switch21_case_42
    elseif ____switch21 == \\"context\\" then
        goto ____switch21_case_43
    elseif ____switch21 == \\"key\\" then
        goto ____switch21_case_44
    end
    goto ____switch21_case_default
    ::____switch21_case_0::
    do
        do
            BlzFrameSetText(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_1::
    do
        do
            BlzFrameSetTextSizeLimit(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_2::
    do
        do
            BlzFrameSetTextColor(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_3::
    do
        do
            BlzFrameSetTexture(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.texture.texFile
                    else
                        return ____lhs
                    end
                end)(val.texFile),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.texture.flag
                    else
                        return ____lhs
                    end
                end)(val.flag),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.texture.blend
                    else
                        return ____lhs
                    end
                end)(val.blend)
            )
            goto ____switch21_end
        end
    end
    ::____switch21_case_4::
    do
        do
            BlzFrameSetModel(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.model.modelFile
                    else
                        return ____lhs
                    end
                end)(val.modelFile),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.model.cameraIndex
                    else
                        return ____lhs
                    end
                end)(val.cameraIndex)
            )
            goto ____switch21_end
        end
    end
    ::____switch21_case_5::
    do
        do
            BlzFrameSetAlpha(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_6::
    do
        do
            BlzFrameSetLevel(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_7::
    do
        do
            BlzFrameSetVisible(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_8::
    do
        do
            BlzFrameSetEnable(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_9::
    do
        do
            BlzFrameSetVertexColor(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_10::
    do
        do
            BlzFrameSetValue(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_11::
    do
        do
            BlzFrameSetSize(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.size.width
                    else
                        return ____lhs
                    end
                end)(val.width),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.size.height
                    else
                        return ____lhs
                    end
                end)(val.height)
            )
            goto ____switch21_end
        end
    end
    ::____switch21_case_12::
    do
        do
            BlzFrameSetStepSize(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_13::
    do
        do
            BlzFrameSetTooltip(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_14::
    do
        do
            BlzFrameSetFont(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.font.fileName
                    else
                        return ____lhs
                    end
                end)(val.fileName),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.font.height
                    else
                        return ____lhs
                    end
                end)(val.height),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.font.flags
                    else
                        return ____lhs
                    end
                end)(val.flags)
            )
            goto ____switch21_end
        end
    end
    ::____switch21_case_15::
    do
        do
            BlzFrameSetMinMaxValue(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.minMaxValue.min
                    else
                        return ____lhs
                    end
                end)(val.min),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.minMaxValue.max
                    else
                        return ____lhs
                    end
                end)(val.max)
            )
            goto ____switch21_end
        end
    end
    ::____switch21_case_16::
    do
        do
            BlzFrameSetScale(frame, val)
            goto ____switch21_end
        end
    end
    ::____switch21_case_17::
    do
        do
            BlzFrameSetSpriteAnimate(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.spriteAnimate.primaryProp
                    else
                        return ____lhs
                    end
                end)(val.primaryProp),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.spriteAnimate.flags
                    else
                        return ____lhs
                    end
                end)(val.flags)
            )
            goto ____switch21_end
        end
    end
    ::____switch21_case_18::
    do
        do
            BlzFrameSetTextAlignment(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.textAlignment.vert
                    else
                        return ____lhs
                    end
                end)(val.vert),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.textAlignment.horz
                    else
                        return ____lhs
                    end
                end)(val.horz)
            )
            goto ____switch21_end
        end
    end
    ::____switch21_case_19::
    do
        do
            if val ~= nil then
                for ____, position in ipairs(val) do
                    if position == \\"clear\\" then
                        BlzFrameClearAllPoints(frame)
                    elseif position == \\"parent\\" then
                        BlzFrameSetAllPoints(
                            frame,
                            BlzFrameGetParent(frame)
                        )
                    else
                        local relative = resolveRelative(frame, position.relative)
                        if relative then
                            BlzFrameSetPoint(frame, position.point, relative, position.relativePoint, position.x or 0, position.y or 0)
                        else
                            local parentRelative = previousToParentPoint(position.relativePoint)
                            if parentRelative then
                                BlzFrameSetPoint(
                                    frame,
                                    position.point,
                                    BlzFrameGetParent(frame),
                                    parentRelative,
                                    position.x or 0,
                                    position.y or 0
                                )
                            end
                        end
                    end
                end
            end
            goto ____switch21_end
        end
    end
    ::____switch21_case_20::
    do
        do
            if val ~= nil then
                for ____, absPosition in ipairs(val) do
                    if absPosition == \\"clear\\" then
                        BlzFrameClearAllPoints(frame)
                    else
                        BlzFrameSetAbsPoint(frame, absPosition.point, absPosition.x or 0, absPosition.y or 0)
                    end
                end
            end
            goto ____switch21_end
        end
    end
    ::____switch21_case_21::
    do
        do
            setEventProp(frame, FRAMEEVENT_CONTROL_CLICK, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_22::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_ENTER, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_23::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_LEAVE, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_24::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_UP, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_25::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_DOWN, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_26::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_WHEEL, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_27::
    do
        do
            setEventProp(frame, FRAMEEVENT_CHECKBOX_CHECKED, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_28::
    do
        do
            setEventProp(frame, FRAMEEVENT_CHECKBOX_UNCHECKED, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_29::
    do
        do
            setEventProp(frame, FRAMEEVENT_EDITBOX_TEXT_CHANGED, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_30::
    do
        do
            setEventProp(frame, FRAMEEVENT_POPUPMENU_ITEM_CHANGED, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_31::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_DOUBLECLICK, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_32::
    do
        do
            setEventProp(frame, FRAMEEVENT_SPRITE_ANIM_UPDATE, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_33::
    do
        do
            setEventProp(frame, FRAMEEVENT_SLIDER_VALUE_CHANGED, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_34::
    do
        do
            setEventProp(frame, FRAMEEVENT_DIALOG_CANCEL, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_35::
    do
        do
            setEventProp(frame, FRAMEEVENT_DIALOG_ACCEPT, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_36::
    do
        do
            setEventProp(frame, FRAMEEVENT_EDITBOX_ENTER, val, _oldValue)
            goto ____switch21_end
        end
    end
    ::____switch21_case_37::
    do
    end
    ::____switch21_case_38::
    do
    end
    ::____switch21_case_39::
    do
    end
    ::____switch21_case_40::
    do
    end
    ::____switch21_case_41::
    do
    end
    ::____switch21_case_42::
    do
    end
    ::____switch21_case_43::
    do
    end
    ::____switch21_case_44::
    do
        goto ____switch21_end
    end
    ::____switch21_case_default::
    do
        absurd(prop)
    end
    ::____switch21_end::
end
local typeNames = {\\"backdrop\\", \\"button\\", \\"chatdisplay\\", \\"checkbox\\", \\"control\\", \\"dialog\\", \\"editbox\\", \\"gluebutton\\", \\"gluecheckbox\\", \\"glueeditbox\\", \\"gluepopupmenu\\", \\"gluetextbutton\\", \\"highlight\\", \\"listbox\\", \\"menu\\", \\"model\\", \\"popupmenu\\", \\"scrollbar\\", \\"slashchatbox\\", \\"slider\\", \\"sprite\\", \\"text\\", \\"textarea\\", \\"textbutton\\", \\"timertext\\"}
local simpleTypeNames = {\\"simple-button\\", \\"simple-checkbox\\", \\"simple-statusbar\\"}
____exports.adapter = {
    createFrame = function(____, jsxType, parentFrame, props)
        local frame
        local name = props.name
        if name == nil then
            name = frameDefaults.name
        end
        local priority = props.priority
        if priority == nil then
            priority = frameDefaults.priority
        end
        local inherits = props.inherits
        local isSimple = props.isSimple
        local context = props.context
        if context == nil then
            context = frameDefaults.context
        end
        local typeName = props.typeName
        if (typeName == nil) and __TS__ArrayIncludes(typeNames, jsxType) then
            typeName = string.upper(jsxType)
        end
        if (typeName == nil) and __TS__ArrayIncludes(simpleTypeNames, jsxType) then
            typeName = string.upper(
                __TS__StringReplace(jsxType, \\"-\\", \\"\\")
            )
        end
        if (typeName == nil) and (jsxType == \\"container\\") then
            typeName = \\"FRAME\\"
        end
        if (typeName == nil) and (jsxType == \\"simple-container\\") then
            typeName = \\"SIMPLEFRAME\\"
        end
        if (function(____lhs)
            if ____lhs == nil then
                return jsxType == \\"simple-frame\\"
            else
                return ____lhs
            end
        end)(isSimple) then
            frame = BlzCreateSimpleFrame(name, parentFrame, context)
        elseif typeName then
            frame = BlzCreateFrameByType(typeName, name, parentFrame, inherits or \\"\\", context)
        else
            frame = BlzCreateFrame(name, parentFrame, priority, context)
        end
        ____exports.adapter:updateFrameProperties(frame, {}, props)
        return frame
    end,
    cleanupFrame = function(____, frame) return BlzDestroyFrame(frame) end,
    updateFrameProperties = function(____, frame, prevProps, nextProps)
        local prop
        for ____value in pairs(prevProps) do
            prop = ____value
            if not (nextProps[prop] ~= nil) then
                do
                    local ____try, err = pcall(
                        function()
                            setProp(frame, prop)
                        end
                    )
                    if not ____try then
                        print(err)
                    end
                end
            end
        end
        for ____value in pairs(nextProps) do
            prop = ____value
            if nextProps[prop] ~= prevProps[prop] then
                do
                    local ____try, err = pcall(
                        function()
                            setProp(frame, prop, nextProps[prop], prevProps[prop])
                        end
                    )
                    if not ____try then
                        print(err)
                    end
                end
            end
        end
    end,
    getParent = function(____, frame) return BlzFrameGetParent(frame) end
}
return ____exports
end,
[\\"src.index\\"] = function() local ____exports = {}
local ____adapter = require(\\"src.adapter\\")
local adapter = ____adapter.adapter
local ____index = require(\\"node_modules.basic-pragma.src.index\\")
local setAdapter = ____index.setAdapter
setAdapter(adapter)
do
    local ____index = require(\\"node_modules.basic-pragma.src.index\\")
    local useState = ____index.useState
    local createElement = ____index.createElement
    local Fragment = ____index.Fragment
    local render = ____index.render
    ____exports.useState = useState
    ____exports.createElement = createElement
    ____exports.Fragment = Fragment
    ____exports.render = render
end
return ____exports
end,
[\\"src.test.sample\\"] = function() local ____exports = {}
local React = require(\\"src.index\\")
local App
App = function() return React.createElement(\\"frame\\", {name = \\"GLUETEXTBUTTON\\"}) end
React.render(
    React.createElement(App, {}),
    BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0)
)
return ____exports
end,
}
return require(\\"src.test.sample\\")
"
`;
