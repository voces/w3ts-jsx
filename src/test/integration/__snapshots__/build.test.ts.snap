// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`works 1`] = `
"
local ____modules = {}
local ____moduleCache = {}
local ____originalRequire = require
local function require(file)
    if ____moduleCache[file] then
        return ____moduleCache[file]
    end
    if ____modules[file] then
        ____moduleCache[file] = ____modules[file]()
        return ____moduleCache[file]
    else
        if ____originalRequire then
            return ____originalRequire(file)
        else
            error(\\"module '\\" .. file .. \\"' not found\\")
        end
    end
end
____modules = {
[\\"lualib_bundle\\"] = function() function __TS__ArrayConcat(arr1, ...)
    local args = {...}
    local out = {}
    for ____, val in ipairs(arr1) do
        out[#out + 1] = val
    end
    for ____, arg in ipairs(args) do
        if pcall(
            function() return #arg end
        ) and (type(arg) ~= \\"string\\") then
            local argAsArray = arg
            for ____, val in ipairs(argAsArray) do
                out[#out + 1] = val
            end
        else
            out[#out + 1] = arg
        end
    end
    return out
end

function __TS__ArrayEvery(arr, callbackfn)
    do
        local i = 0
        while i < #arr do
            if not callbackfn(_G, arr[i + 1], i, arr) then
                return false
            end
            i = i + 1
        end
    end
    return true
end

function __TS__ArrayFilter(arr, callbackfn)
    local result = {}
    do
        local i = 0
        while i < #arr do
            if callbackfn(_G, arr[i + 1], i, arr) then
                result[#result + 1] = arr[i + 1]
            end
            i = i + 1
        end
    end
    return result
end

function __TS__ArrayForEach(arr, callbackFn)
    do
        local i = 0
        while i < #arr do
            callbackFn(_G, arr[i + 1], i, arr)
            i = i + 1
        end
    end
end

function __TS__ArrayFind(arr, predicate)
    local len = #arr
    local k = 0
    while k < len do
        local elem = arr[k + 1]
        if predicate(_G, elem, k, arr) then
            return elem
        end
        k = k + 1
    end
    return nil
end

function __TS__ArrayFindIndex(arr, callbackFn)
    do
        local i = 0
        local len = #arr
        while i < len do
            if callbackFn(_G, arr[i + 1], i, arr) then
                return i
            end
            i = i + 1
        end
    end
    return -1
end

function __TS__ArrayIncludes(self, searchElement, fromIndex)
    if fromIndex == nil then
        fromIndex = 0
    end
    local len = #self
    local k = fromIndex
    if fromIndex < 0 then
        k = len + fromIndex
    end
    if k < 0 then
        k = 0
    end
    for i = k, len do
        if self[i + 1] == searchElement then
            return true
        end
    end
    return false
end

function __TS__ArrayIndexOf(arr, searchElement, fromIndex)
    local len = #arr
    if len == 0 then
        return -1
    end
    local n = 0
    if fromIndex then
        n = fromIndex
    end
    if n >= len then
        return -1
    end
    local k
    if n >= 0 then
        k = n
    else
        k = len + n
        if k < 0 then
            k = 0
        end
    end
    do
        local i = k
        while i < len do
            if arr[i + 1] == searchElement then
                return i
            end
            i = i + 1
        end
    end
    return -1
end

function __TS__ArrayJoin(self, separator)
    if separator == nil then
        separator = \\",\\"
    end
    local result = \\"\\"
    for index, value in ipairs(self) do
        if index > 1 then
            result = tostring(result) .. tostring(separator)
        end
        result = tostring(result) .. tostring(
            tostring(value)
        )
    end
    return result
end

function __TS__ArrayMap(arr, callbackfn)
    local newArray = {}
    do
        local i = 0
        while i < #arr do
            newArray[i + 1] = callbackfn(_G, arr[i + 1], i, arr)
            i = i + 1
        end
    end
    return newArray
end

function __TS__ArrayPush(arr, ...)
    local items = {...}
    for ____, item in ipairs(items) do
        arr[#arr + 1] = item
    end
    return #arr
end

function __TS__ArrayReduce(arr, callbackFn, ...)
    local len = #arr
    local k = 0
    local accumulator = nil
    if select(\\"#\\", ...) ~= 0 then
        accumulator = select(1, ...)
    elseif len > 0 then
        accumulator = arr[1]
        k = 1
    else
        error(\\"Reduce of empty array with no initial value\\", 0)
    end
    for i = k, len - 1 do
        accumulator = callbackFn(_G, accumulator, arr[i + 1], i, arr)
    end
    return accumulator
end

function __TS__ArrayReduceRight(arr, callbackFn, ...)
    local len = #arr
    local k = len - 1
    local accumulator = nil
    if select(\\"#\\", ...) ~= 0 then
        accumulator = select(1, ...)
    elseif len > 0 then
        accumulator = arr[k + 1]
        k = k - 1
    else
        error(\\"Reduce of empty array with no initial value\\", 0)
    end
    for i = k, 0, -1 do
        accumulator = callbackFn(_G, accumulator, arr[i + 1], i, arr)
    end
    return accumulator
end

function __TS__ArrayReverse(arr)
    local i = 0
    local j = #arr - 1
    while i < j do
        local temp = arr[j + 1]
        arr[j + 1] = arr[i + 1]
        arr[i + 1] = temp
        i = i + 1
        j = j - 1
    end
    return arr
end

function __TS__ArrayShift(arr)
    return table.remove(arr, 1)
end

function __TS__ArrayUnshift(arr, ...)
    local items = {...}
    do
        local i = #items - 1
        while i >= 0 do
            table.insert(arr, 1, items[i + 1])
            i = i - 1
        end
    end
    return #arr
end

function __TS__ArraySort(arr, compareFn)
    if compareFn ~= nil then
        table.sort(
            arr,
            function(a, b) return compareFn(_G, a, b) < 0 end
        )
    else
        table.sort(arr)
    end
    return arr
end

function __TS__ArraySlice(list, first, last)
    local len = #list
    local relativeStart = first or 0
    local k
    if relativeStart < 0 then
        k = math.max(len + relativeStart, 0)
    else
        k = math.min(relativeStart, len)
    end
    local relativeEnd = last
    if last == nil then
        relativeEnd = len
    end
    local final
    if relativeEnd < 0 then
        final = math.max(len + relativeEnd, 0)
    else
        final = math.min(relativeEnd, len)
    end
    local out = {}
    local n = 0
    while k < final do
        out[n + 1] = list[k + 1]
        k = k + 1
        n = n + 1
    end
    return out
end

function __TS__ArraySome(arr, callbackfn)
    do
        local i = 0
        while i < #arr do
            if callbackfn(_G, arr[i + 1], i, arr) then
                return true
            end
            i = i + 1
        end
    end
    return false
end

function __TS__ArraySplice(list, ...)
    local len = #list
    local actualArgumentCount = select(\\"#\\", ...)
    local start = select(1, ...)
    local deleteCount = select(2, ...)
    local actualStart
    if start < 0 then
        actualStart = math.max(len + start, 0)
    else
        actualStart = math.min(start, len)
    end
    local itemCount = math.max(actualArgumentCount - 2, 0)
    local actualDeleteCount
    if actualArgumentCount == 0 then
        actualDeleteCount = 0
    elseif actualArgumentCount == 1 then
        actualDeleteCount = len - actualStart
    else
        actualDeleteCount = math.min(
            math.max(deleteCount or 0, 0),
            len - actualStart
        )
    end
    local out = {}
    do
        local k = 0
        while k < actualDeleteCount do
            local from = actualStart + k
            if list[from + 1] then
                out[k + 1] = list[from + 1]
            end
            k = k + 1
        end
    end
    if itemCount < actualDeleteCount then
        do
            local k = actualStart
            while k < (len - actualDeleteCount) do
                local from = k + actualDeleteCount
                local to = k + itemCount
                if list[from + 1] then
                    list[to + 1] = list[from + 1]
                else
                    list[to + 1] = nil
                end
                k = k + 1
            end
        end
        do
            local k = len
            while k > ((len - actualDeleteCount) + itemCount) do
                list[k] = nil
                k = k - 1
            end
        end
    elseif itemCount > actualDeleteCount then
        do
            local k = len - actualDeleteCount
            while k > actualStart do
                local from = (k + actualDeleteCount) - 1
                local to = (k + itemCount) - 1
                if list[from + 1] then
                    list[to + 1] = list[from + 1]
                else
                    list[to + 1] = nil
                end
                k = k - 1
            end
        end
    end
    local j = actualStart
    for i = 3, actualArgumentCount do
        list[j + 1] = select(i, ...)
        j = j + 1
    end
    do
        local k = #list - 1
        while k >= ((len - actualDeleteCount) + itemCount) do
            list[k + 1] = nil
            k = k - 1
        end
    end
    return out
end

function __TS__ArrayToObject(array)
    local object = {}
    do
        local i = 0
        while i < #array do
            object[i] = array[i + 1]
            i = i + 1
        end
    end
    return object
end

function __TS__ArrayFlat(array, depth)
    if depth == nil then
        depth = 1
    end
    local result = {}
    for ____, value in ipairs(array) do
        if ((depth > 0) and (type(value) == \\"table\\")) and ((value[1] ~= nil) or (next(value, nil) == nil)) then
            result = __TS__ArrayConcat(
                result,
                __TS__ArrayFlat(value, depth - 1)
            )
        else
            result[#result + 1] = value
        end
    end
    return result
end

function __TS__ArrayFlatMap(array, callback)
    local result = {}
    do
        local i = 0
        while i < #array do
            local value = callback(_G, array[i + 1], i, array)
            if (type(value) == \\"table\\") and ((value[1] ~= nil) or (next(value, nil) == nil)) then
                result = __TS__ArrayConcat(result, value)
            else
                result[#result + 1] = value
            end
            i = i + 1
        end
    end
    return result
end

function __TS__ArraySetLength(arr, length)
    if (((length < 0) or (length ~= length)) or (length == math.huge)) or (math.floor(length) ~= length) then
        error(
            \\"invalid array length: \\" .. tostring(length),
            0
        )
    end
    do
        local i = #arr - 1
        while i >= length do
            arr[i + 1] = nil
            i = i - 1
        end
    end
    return length
end

function __TS__Class(self)
    local c = {prototype = {}}
    c.prototype.__index = c.prototype
    c.prototype.constructor = c
    return c
end

function __TS__ClassExtends(target, base)
    target.____super = base
    local staticMetatable = setmetatable({__index = base}, base)
    setmetatable(target, staticMetatable)
    local baseMetatable = getmetatable(base)
    if baseMetatable then
        if type(baseMetatable.__index) == \\"function\\" then
            staticMetatable.__index = baseMetatable.__index
        end
        if type(baseMetatable.__newindex) == \\"function\\" then
            staticMetatable.__newindex = baseMetatable.__newindex
        end
    end
    setmetatable(target.prototype, base.prototype)
    if type(base.prototype.__index) == \\"function\\" then
        target.prototype.__index = base.prototype.__index
    end
    if type(base.prototype.__newindex) == \\"function\\" then
        target.prototype.__newindex = base.prototype.__newindex
    end
    if type(base.prototype.__tostring) == \\"function\\" then
        target.prototype.__tostring = base.prototype.__tostring
    end
end

function __TS__CloneDescriptor(____bindingPattern0)
    local enumerable
    enumerable = ____bindingPattern0.enumerable
    local configurable
    configurable = ____bindingPattern0.configurable
    local get
    get = ____bindingPattern0.get
    local set
    set = ____bindingPattern0.set
    local writable
    writable = ____bindingPattern0.writable
    local value
    value = ____bindingPattern0.value
    local descriptor = {enumerable = enumerable == true, configurable = configurable == true}
    local hasGetterOrSetter = (get ~= nil) or (set ~= nil)
    local hasValueOrWritableAttribute = (writable ~= nil) or (value ~= nil)
    if hasGetterOrSetter and hasValueOrWritableAttribute then
        error(\\"Invalid property descriptor. Cannot both specify accessors and a value or writable attribute.\\", 0)
    end
    if get or set then
        descriptor.get = get
        descriptor.set = set
    else
        descriptor.value = value
        descriptor.writable = writable == true
    end
    return descriptor
end

function __TS__Decorate(decorators, target, key, desc)
    local result = target
    do
        local i = #decorators
        while i >= 0 do
            local decorator = decorators[i + 1]
            if decorator then
                local oldResult = result
                if key == nil then
                    result = decorator(_G, result)
                elseif desc == true then
                    local value = rawget(target, key)
                    local descriptor = __TS__ObjectGetOwnPropertyDescriptor(target, key) or ({configurable = true, writable = true, value = value})
                    local desc = decorator(_G, target, key, descriptor) or descriptor
                    local isSimpleValue = (((desc.configurable == true) and (desc.writable == true)) and (not desc.get)) and (not desc.set)
                    if isSimpleValue then
                        rawset(target, key, desc.value)
                    else
                        __TS__SetDescriptor(
                            target,
                            key,
                            __TS__ObjectAssign({}, descriptor, desc)
                        )
                    end
                elseif desc == false then
                    result = decorator(_G, target, key, desc)
                else
                    result = decorator(_G, target, key)
                end
                result = result or oldResult
            end
            i = i - 1
        end
    end
    return result
end

function __TS__DecorateParam(paramIndex, decorator)
    return function(____, target, key) return decorator(_G, target, key, paramIndex) end
end

function __TS__ObjectGetOwnPropertyDescriptors(object)
    local metatable = getmetatable(object)
    if not metatable then
        return {}
    end
    return rawget(metatable, \\"_descriptors\\")
end

function __TS__Delete(target, key)
    local descriptors = __TS__ObjectGetOwnPropertyDescriptors(target)
    local descriptor = descriptors[key]
    if descriptor then
        if not descriptor.configurable then
            error(
                (((\\"Cannot delete property \\" .. tostring(key)) .. \\" of \\") .. tostring(target)) .. \\".\\",
                0
            )
        end
        descriptors[key] = nil
        return true
    end
    if target[key] ~= nil then
        target[key] = nil
        return true
    end
    return false
end

function __TS__DelegatedYield(iterable)
    if type(iterable) == \\"string\\" then
        for index = 0, #iterable - 1 do
            coroutine.yield(
                __TS__StringAccess(iterable, index)
            )
        end
    elseif iterable.____coroutine ~= nil then
        local co = iterable.____coroutine
        while true do
            local status, value = coroutine.resume(co)
            if not status then
                error(value, 0)
            end
            if coroutine.status(co) == \\"dead\\" then
                return value
            else
                coroutine.yield(value)
            end
        end
    elseif iterable[Symbol.iterator] then
        local iterator = iterable[Symbol.iterator](iterable)
        while true do
            local result = iterator:next()
            if result.done then
                return result.value
            else
                coroutine.yield(result.value)
            end
        end
    else
        for ____, value in ipairs(iterable) do
            coroutine.yield(value)
        end
    end
end

function __TS__New(target, ...)
    local instance = setmetatable({}, target.prototype)
    instance:____constructor(...)
    return instance
end

function __TS__GetErrorStack(self, constructor)
    local level = 1
    while true do
        local info = debug.getinfo(level, \\"f\\")
        level = level + 1
        if not info then
            level = 1
            break
        elseif info.func == constructor then
            break
        end
    end
    return debug.traceback(nil, level)
end
function __TS__WrapErrorToString(self, getDescription)
    return function(self)
        local description = getDescription(self)
        local caller = debug.getinfo(3, \\"f\\")
        if (_VERSION == \\"Lua 5.1\\") or (caller and (caller.func ~= error)) then
            return description
        else
            return (tostring(description) .. \\"\\\\n\\") .. tostring(self.stack)
        end
    end
end
function __TS__InitErrorClass(self, Type, name)
    Type.name = name
    return setmetatable(
        Type,
        {
            __call = function(____, _self, message) return __TS__New(Type, message) end
        }
    )
end
Error = __TS__InitErrorClass(
    _G,
    (function()
        local ____ = __TS__Class()
        ____.name = \\"\\"
        function ____.prototype.____constructor(self, message)
            if message == nil then
                message = \\"\\"
            end
            self.message = message
            self.name = \\"Error\\"
            self.stack = __TS__GetErrorStack(_G, self.constructor.new)
            local metatable = getmetatable(self)
            if not metatable.__errorToStringPatched then
                metatable.__errorToStringPatched = true
                metatable.__tostring = __TS__WrapErrorToString(_G, metatable.__tostring)
            end
        end
        function ____.prototype.__tostring(self)
            return (((self.message ~= \\"\\") and (function() return (tostring(self.name) .. \\": \\") .. tostring(self.message) end)) or (function() return self.name end))()
        end
        return ____
    end)(),
    \\"Error\\"
)
for ____, errorName in ipairs({\\"RangeError\\", \\"ReferenceError\\", \\"SyntaxError\\", \\"TypeError\\", \\"URIError\\"}) do
    _G[errorName] = __TS__InitErrorClass(
        _G,
        (function()
            local ____ = __TS__Class()
            ____.name = ____.name
            __TS__ClassExtends(____, Error)
            function ____.prototype.____constructor(self, ...)
                Error.prototype.____constructor(self, ...)
                self.name = errorName
            end
            return ____
        end)(),
        errorName
    )
end

__TS__Unpack = table.unpack or unpack

function __TS__FunctionBind(fn, thisArg, ...)
    local boundArgs = {...}
    return function(____, ...)
        local args = {...}
        do
            local i = 0
            while i < #boundArgs do
                table.insert(args, i + 1, boundArgs[i + 1])
                i = i + 1
            end
        end
        return fn(
            thisArg,
            __TS__Unpack(args)
        )
    end
end

____symbolMetatable = {
    __tostring = function(self)
        return (\\"Symbol(\\" .. tostring(self.description or \\"\\")) .. \\")\\"
    end
}
function __TS__Symbol(description)
    return setmetatable({description = description}, ____symbolMetatable)
end
Symbol = {
    iterator = __TS__Symbol(\\"Symbol.iterator\\"),
    hasInstance = __TS__Symbol(\\"Symbol.hasInstance\\"),
    species = __TS__Symbol(\\"Symbol.species\\"),
    toStringTag = __TS__Symbol(\\"Symbol.toStringTag\\")
}

function __TS__GeneratorIterator(self)
    return self
end
function __TS__GeneratorNext(self, ...)
    local co = self.____coroutine
    if coroutine.status(co) == \\"dead\\" then
        return {done = true}
    end
    local status, value = coroutine.resume(co, ...)
    if not status then
        error(value, 0)
    end
    return {
        value = value,
        done = coroutine.status(co) == \\"dead\\"
    }
end
function __TS__Generator(fn)
    return function(...)
        local args = {...}
        local argsLength = select(\\"#\\", ...)
        return {
            ____coroutine = coroutine.create(
                function() return fn(
                    (unpack or table.unpack)(args, 1, argsLength)
                ) end
            ),
            [Symbol.iterator] = __TS__GeneratorIterator,
            next = __TS__GeneratorNext
        }
    end
end

function __TS__InstanceOf(obj, classTbl)
    if type(classTbl) ~= \\"table\\" then
        error(\\"Right-hand side of 'instanceof' is not an object\\", 0)
    end
    if classTbl[Symbol.hasInstance] ~= nil then
        return not (not classTbl[Symbol.hasInstance](classTbl, obj))
    end
    if type(obj) == \\"table\\" then
        local luaClass = obj.constructor
        while luaClass ~= nil do
            if luaClass == classTbl then
                return true
            end
            luaClass = luaClass.____super
        end
    end
    return false
end

function __TS__InstanceOfObject(value)
    local valueType = type(value)
    return (valueType == \\"table\\") or (valueType == \\"function\\")
end

function __TS__IteratorGeneratorStep(self)
    local co = self.____coroutine
    local status, value = coroutine.resume(co)
    if not status then
        error(value, 0)
    end
    if coroutine.status(co) == \\"dead\\" then
        return
    end
    return true, value
end
function __TS__IteratorIteratorStep(self)
    local result = self:next()
    if result.done then
        return
    end
    return true, result.value
end
function __TS__IteratorStringStep(self, index)
    index = index + 1
    if index > #self then
        return
    end
    return index, string.sub(self, index, index)
end
function __TS__Iterator(iterable)
    if type(iterable) == \\"string\\" then
        return __TS__IteratorStringStep, iterable, 0
    elseif iterable.____coroutine ~= nil then
        return __TS__IteratorGeneratorStep, iterable
    elseif iterable[Symbol.iterator] then
        local iterator = iterable[Symbol.iterator](iterable)
        return __TS__IteratorIteratorStep, iterator
    else
        return ipairs(iterable)
    end
end

Map = (function()
    local Map = __TS__Class()
    Map.name = \\"Map\\"
    function Map.prototype.____constructor(self, entries)
        self[Symbol.toStringTag] = \\"Map\\"
        self.items = {}
        self.size = 0
        self.nextKey = {}
        self.previousKey = {}
        if entries == nil then
            return
        end
        local iterable = entries
        if iterable[Symbol.iterator] then
            local iterator = iterable[Symbol.iterator](iterable)
            while true do
                local result = iterator:next()
                if result.done then
                    break
                end
                local value = result.value
                self:set(value[1], value[2])
            end
        else
            local array = entries
            for ____, kvp in ipairs(array) do
                self:set(kvp[1], kvp[2])
            end
        end
    end
    function Map.prototype.clear(self)
        self.items = {}
        self.nextKey = {}
        self.previousKey = {}
        self.firstKey = nil
        self.lastKey = nil
        self.size = 0
    end
    function Map.prototype.delete(self, key)
        local contains = self:has(key)
        if contains then
            self.size = self.size - 1
            local next = self.nextKey[key]
            local previous = self.previousKey[key]
            if next and previous then
                self.nextKey[previous] = next
                self.previousKey[next] = previous
            elseif next then
                self.firstKey = next
                self.previousKey[next] = nil
            elseif previous then
                self.lastKey = previous
                self.nextKey[previous] = nil
            else
                self.firstKey = nil
                self.lastKey = nil
            end
            self.nextKey[key] = nil
            self.previousKey[key] = nil
        end
        self.items[key] = nil
        return contains
    end
    function Map.prototype.forEach(self, callback)
        for ____, key in __TS__Iterator(
            self:keys()
        ) do
            callback(_G, self.items[key], key, self)
        end
    end
    function Map.prototype.get(self, key)
        return self.items[key]
    end
    function Map.prototype.has(self, key)
        return (self.nextKey[key] ~= nil) or (self.lastKey == key)
    end
    function Map.prototype.set(self, key, value)
        local isNewValue = not self:has(key)
        if isNewValue then
            self.size = self.size + 1
        end
        self.items[key] = value
        if self.firstKey == nil then
            self.firstKey = key
            self.lastKey = key
        elseif isNewValue then
            self.nextKey[self.lastKey] = key
            self.previousKey[key] = self.lastKey
            self.lastKey = key
        end
        return self
    end
    Map.prototype[Symbol.iterator] = function(self)
        return self:entries()
    end
    function Map.prototype.entries(self)
        local ____ = self
        local items = ____.items
        local nextKey = ____.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = {key, items[key]}}
                key = nextKey[key]
                return result
            end
        }
    end
    function Map.prototype.keys(self)
        local nextKey = self.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = key}
                key = nextKey[key]
                return result
            end
        }
    end
    function Map.prototype.values(self)
        local ____ = self
        local items = ____.items
        local nextKey = ____.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = items[key]}
                key = nextKey[key]
                return result
            end
        }
    end
    Map[Symbol.species] = Map
    return Map
end)()

__TS__MathAtan2 = math.atan2 or math.atan

function __TS__Number(value)
    local valueType = type(value)
    if valueType == \\"number\\" then
        return value
    elseif valueType == \\"string\\" then
        local numberValue = tonumber(value)
        if numberValue then
            return numberValue
        end
        if value == \\"Infinity\\" then
            return math.huge
        end
        if value == \\"-Infinity\\" then
            return -math.huge
        end
        local stringWithoutSpaces = string.gsub(value, \\"%s\\", \\"\\")
        if stringWithoutSpaces == \\"\\" then
            return 0
        end
        return 0 / 0
    elseif valueType == \\"boolean\\" then
        return (value and 1) or 0
    else
        return 0 / 0
    end
end

function __TS__NumberIsFinite(value)
    return (((type(value) == \\"number\\") and (value == value)) and (value ~= math.huge)) and (value ~= -math.huge)
end

function __TS__NumberIsNaN(value)
    return value ~= value
end

____radixChars = \\"0123456789abcdefghijklmnopqrstuvwxyz\\"
function __TS__NumberToString(self, radix)
    if ((((radix == nil) or (radix == 10)) or (self == math.huge)) or (self == -math.huge)) or (self ~= self) then
        return tostring(self)
    end
    radix = math.floor(radix)
    if (radix < 2) or (radix > 36) then
        error(\\"toString() radix argument must be between 2 and 36\\", 0)
    end
    local integer, fraction = math.modf(
        math.abs(self)
    )
    local result = \\"\\"
    if radix == 8 then
        result = string.format(\\"%o\\", integer)
    elseif radix == 16 then
        result = string.format(\\"%x\\", integer)
    else
        repeat
            do
                result = tostring(
                    __TS__StringAccess(____radixChars, integer % radix)
                ) .. tostring(result)
                integer = math.floor(integer / radix)
            end
        until not (integer ~= 0)
    end
    if fraction ~= 0 then
        result = tostring(result) .. \\".\\"
        local delta = 1e-16
        repeat
            do
                fraction = fraction * radix
                delta = delta * radix
                local digit = math.floor(fraction)
                result = tostring(result) .. tostring(
                    __TS__StringAccess(____radixChars, digit)
                )
                fraction = fraction - digit
            end
        until not (fraction >= delta)
    end
    if self < 0 then
        result = \\"-\\" .. tostring(result)
    end
    return result
end

function __TS__ObjectAssign(to, ...)
    local sources = {...}
    if to == nil then
        return to
    end
    for ____, source in ipairs(sources) do
        for key in pairs(source) do
            to[key] = source[key]
        end
    end
    return to
end

function ____descriptorIndex(self, key)
    local value = rawget(self, key)
    if value ~= nil then
        return value
    end
    local metatable = getmetatable(self)
    while metatable do
        local rawResult = rawget(metatable, key)
        if rawResult ~= nil then
            return rawResult
        end
        local descriptors = rawget(metatable, \\"_descriptors\\")
        if descriptors then
            local descriptor = descriptors[key]
            if descriptor then
                if descriptor.get then
                    return descriptor.get(self)
                end
                return descriptor.value
            end
        end
        metatable = getmetatable(metatable)
    end
end
function ____descriptorNewindex(self, key, value)
    local metatable = getmetatable(self)
    while metatable do
        local descriptors = rawget(metatable, \\"_descriptors\\")
        if descriptors then
            local descriptor = descriptors[key]
            if descriptor then
                if descriptor.set then
                    descriptor.set(self, value)
                else
                    if descriptor.writable == false then
                        error(
                            (((\\"Cannot assign to read only property '\\" .. tostring(key)) .. \\"' of object '\\") .. tostring(self)) .. \\"'\\",
                            0
                        )
                    end
                    descriptor.value = value
                end
                return
            end
        end
        metatable = getmetatable(metatable)
    end
    rawset(self, key, value)
end
function __TS__SetDescriptor(target, key, desc, isPrototype)
    if isPrototype == nil then
        isPrototype = false
    end
    local metatable = ((isPrototype and (function() return target end)) or (function() return getmetatable(target) end))()
    if not metatable then
        metatable = {}
        setmetatable(target, metatable)
    end
    local value = rawget(target, key)
    if value ~= nil then
        rawset(target, key, nil)
    end
    if not rawget(metatable, \\"_descriptors\\") then
        metatable._descriptors = {}
    end
    local descriptor = __TS__CloneDescriptor(desc)
    metatable._descriptors[key] = descriptor
    metatable.__index = ____descriptorIndex
    metatable.__newindex = ____descriptorNewindex
end

function __TS__ObjectDefineProperty(target, key, desc)
    local luaKey = (((type(key) == \\"number\\") and (function() return key + 1 end)) or (function() return key end))()
    local value = rawget(target, luaKey)
    local hasGetterOrSetter = (desc.get ~= nil) or (desc.set ~= nil)
    local descriptor
    if hasGetterOrSetter then
        if value ~= nil then
            error(
                \\"Cannot redefine property: \\" .. tostring(key),
                0
            )
        end
        descriptor = desc
    else
        local valueExists = value ~= nil
        descriptor = {
            set = desc.set,
            get = desc.get,
            configurable = (((desc.configurable ~= nil) and (function() return desc.configurable end)) or (function() return valueExists end))(),
            enumerable = (((desc.enumerable ~= nil) and (function() return desc.enumerable end)) or (function() return valueExists end))(),
            writable = (((desc.writable ~= nil) and (function() return desc.writable end)) or (function() return valueExists end))(),
            value = (((desc.value ~= nil) and (function() return desc.value end)) or (function() return value end))()
        }
    end
    __TS__SetDescriptor(target, luaKey, descriptor)
    return target
end

function __TS__ObjectEntries(obj)
    local result = {}
    for key in pairs(obj) do
        result[#result + 1] = {key, obj[key]}
    end
    return result
end

function __TS__ObjectFromEntries(entries)
    local obj = {}
    local iterable = entries
    if iterable[Symbol.iterator] then
        local iterator = iterable[Symbol.iterator](iterable)
        while true do
            local result = iterator:next()
            if result.done then
                break
            end
            local value = result.value
            obj[value[1]] = value[2]
        end
    else
        for ____, entry in ipairs(entries) do
            obj[entry[1]] = entry[2]
        end
    end
    return obj
end

function __TS__ObjectGetOwnPropertyDescriptor(object, key)
    local metatable = getmetatable(object)
    if not metatable then
        return
    end
    if not rawget(metatable, \\"_descriptors\\") then
        return
    end
    return rawget(metatable, \\"_descriptors\\")[key]
end

function __TS__ObjectKeys(obj)
    local result = {}
    for key in pairs(obj) do
        result[#result + 1] = key
    end
    return result
end

function __TS__ObjectRest(target, usedProperties)
    local result = {}
    for property in pairs(target) do
        if not usedProperties[property] then
            result[property] = target[property]
        end
    end
    return result
end

function __TS__ObjectValues(obj)
    local result = {}
    for key in pairs(obj) do
        result[#result + 1] = obj[key]
    end
    return result
end

function __TS__ParseFloat(numberString)
    local infinityMatch = string.match(numberString, \\"^%s*(-?Infinity)\\")
    if infinityMatch then
        return (((__TS__StringAccess(infinityMatch, 0) == \\"-\\") and (function() return -math.huge end)) or (function() return math.huge end))()
    end
    local number = tonumber(
        string.match(numberString, \\"^%s*(-?%d+%.?%d*)\\")
    )
    return number or (0 / 0)
end

__TS__parseInt_base_pattern = \\"0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTvVwWxXyYzZ\\"
function __TS__ParseInt(numberString, base)
    if base == nil then
        base = 10
        local hexMatch = string.match(numberString, \\"^%s*-?0[xX]\\")
        if hexMatch then
            base = 16
            numberString = ((string.match(hexMatch, \\"-\\") and (function() return \\"-\\" .. tostring(
                __TS__StringSubstr(numberString, #hexMatch)
            ) end)) or (function() return __TS__StringSubstr(numberString, #hexMatch) end))()
        end
    end
    if (base < 2) or (base > 36) then
        return 0 / 0
    end
    local allowedDigits = (((base <= 10) and (function() return __TS__StringSubstring(__TS__parseInt_base_pattern, 0, base) end)) or (function() return __TS__StringSubstr(__TS__parseInt_base_pattern, 0, 10 + (2 * (base - 10))) end))()
    local pattern = (\\"^%s*(-?[\\" .. tostring(allowedDigits)) .. \\"]*)\\"
    local number = tonumber(
        string.match(numberString, pattern),
        base
    )
    if number == nil then
        return 0 / 0
    end
    if number >= 0 then
        return math.floor(number)
    else
        return math.ceil(number)
    end
end

Set = (function()
    local Set = __TS__Class()
    Set.name = \\"Set\\"
    function Set.prototype.____constructor(self, values)
        self[Symbol.toStringTag] = \\"Set\\"
        self.size = 0
        self.nextKey = {}
        self.previousKey = {}
        if values == nil then
            return
        end
        local iterable = values
        if iterable[Symbol.iterator] then
            local iterator = iterable[Symbol.iterator](iterable)
            while true do
                local result = iterator:next()
                if result.done then
                    break
                end
                self:add(result.value)
            end
        else
            local array = values
            for ____, value in ipairs(array) do
                self:add(value)
            end
        end
    end
    function Set.prototype.add(self, value)
        local isNewValue = not self:has(value)
        if isNewValue then
            self.size = self.size + 1
        end
        if self.firstKey == nil then
            self.firstKey = value
            self.lastKey = value
        elseif isNewValue then
            self.nextKey[self.lastKey] = value
            self.previousKey[value] = self.lastKey
            self.lastKey = value
        end
        return self
    end
    function Set.prototype.clear(self)
        self.nextKey = {}
        self.previousKey = {}
        self.firstKey = nil
        self.lastKey = nil
        self.size = 0
    end
    function Set.prototype.delete(self, value)
        local contains = self:has(value)
        if contains then
            self.size = self.size - 1
            local next = self.nextKey[value]
            local previous = self.previousKey[value]
            if next and previous then
                self.nextKey[previous] = next
                self.previousKey[next] = previous
            elseif next then
                self.firstKey = next
                self.previousKey[next] = nil
            elseif previous then
                self.lastKey = previous
                self.nextKey[previous] = nil
            else
                self.firstKey = nil
                self.lastKey = nil
            end
            self.nextKey[value] = nil
            self.previousKey[value] = nil
        end
        return contains
    end
    function Set.prototype.forEach(self, callback)
        for ____, key in __TS__Iterator(
            self:keys()
        ) do
            callback(_G, key, key, self)
        end
    end
    function Set.prototype.has(self, value)
        return (self.nextKey[value] ~= nil) or (self.lastKey == value)
    end
    Set.prototype[Symbol.iterator] = function(self)
        return self:values()
    end
    function Set.prototype.entries(self)
        local nextKey = self.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = {key, key}}
                key = nextKey[key]
                return result
            end
        }
    end
    function Set.prototype.keys(self)
        local nextKey = self.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = key}
                key = nextKey[key]
                return result
            end
        }
    end
    function Set.prototype.values(self)
        local nextKey = self.nextKey
        local key = self.firstKey
        return {
            [Symbol.iterator] = function(self)
                return self
            end,
            next = function(self)
                local result = {done = not key, value = key}
                key = nextKey[key]
                return result
            end
        }
    end
    Set[Symbol.species] = Set
    return Set
end)()

WeakMap = (function()
    local WeakMap = __TS__Class()
    WeakMap.name = \\"WeakMap\\"
    function WeakMap.prototype.____constructor(self, entries)
        self[Symbol.toStringTag] = \\"WeakMap\\"
        self.items = {}
        setmetatable(self.items, {__mode = \\"k\\"})
        if entries == nil then
            return
        end
        local iterable = entries
        if iterable[Symbol.iterator] then
            local iterator = iterable[Symbol.iterator](iterable)
            while true do
                local result = iterator:next()
                if result.done then
                    break
                end
                local value = result.value
                self.items[value[1]] = value[2]
            end
        else
            for ____, kvp in ipairs(entries) do
                self.items[kvp[1]] = kvp[2]
            end
        end
    end
    function WeakMap.prototype.delete(self, key)
        local contains = self:has(key)
        self.items[key] = nil
        return contains
    end
    function WeakMap.prototype.get(self, key)
        return self.items[key]
    end
    function WeakMap.prototype.has(self, key)
        return self.items[key] ~= nil
    end
    function WeakMap.prototype.set(self, key, value)
        self.items[key] = value
        return self
    end
    WeakMap[Symbol.species] = WeakMap
    return WeakMap
end)()

WeakSet = (function()
    local WeakSet = __TS__Class()
    WeakSet.name = \\"WeakSet\\"
    function WeakSet.prototype.____constructor(self, values)
        self[Symbol.toStringTag] = \\"WeakSet\\"
        self.items = {}
        setmetatable(self.items, {__mode = \\"k\\"})
        if values == nil then
            return
        end
        local iterable = values
        if iterable[Symbol.iterator] then
            local iterator = iterable[Symbol.iterator](iterable)
            while true do
                local result = iterator:next()
                if result.done then
                    break
                end
                self.items[result.value] = true
            end
        else
            for ____, value in ipairs(values) do
                self.items[value] = true
            end
        end
    end
    function WeakSet.prototype.add(self, value)
        self.items[value] = true
        return self
    end
    function WeakSet.prototype.delete(self, value)
        local contains = self:has(value)
        self.items[value] = nil
        return contains
    end
    function WeakSet.prototype.has(self, value)
        return self.items[value] == true
    end
    WeakSet[Symbol.species] = WeakSet
    return WeakSet
end)()

function __TS__SourceMapTraceBack(fileName, sourceMap)
    _G.__TS__sourcemap = _G.__TS__sourcemap or ({})
    _G.__TS__sourcemap[fileName] = sourceMap
    if _G.__TS__originalTraceback == nil then
        _G.__TS__originalTraceback = debug.traceback
        debug.traceback = function(thread, message, level)
            local trace
            if ((thread == nil) and (message == nil)) and (level == nil) then
                trace = _G.__TS__originalTraceback()
            else
                trace = _G.__TS__originalTraceback(thread, message, level)
            end
            if type(trace) ~= \\"string\\" then
                return trace
            end
            local result = string.gsub(
                trace,
                \\"(%S+).lua:(%d+)\\",
                function(file, line)
                    local fileSourceMap = _G.__TS__sourcemap[tostring(file) .. \\".lua\\"]
                    if fileSourceMap and fileSourceMap[line] then
                        return (tostring(file) .. \\".ts:\\") .. tostring(fileSourceMap[line])
                    end
                    return (tostring(file) .. \\".lua:\\") .. tostring(line)
                end
            )
            return result
        end
    end
end

function __TS__Spread(iterable)
    local arr = {}
    if type(iterable) == \\"string\\" then
        do
            local i = 0
            while i < #iterable do
                arr[#arr + 1] = __TS__StringAccess(iterable, i)
                i = i + 1
            end
        end
    else
        for ____, item in __TS__Iterator(iterable) do
            arr[#arr + 1] = item
        end
    end
    return __TS__Unpack(arr)
end

function __TS__StringAccess(self, index)
    if (index >= 0) and (index < #self) then
        return string.sub(self, index + 1, index + 1)
    end
end

function __TS__StringCharAt(self, pos)
    if pos ~= pos then
        pos = 0
    end
    if pos < 0 then
        return \\"\\"
    end
    return string.sub(self, pos + 1, pos + 1)
end

function __TS__StringCharCodeAt(self, index)
    if index ~= index then
        index = 0
    end
    if index < 0 then
        return 0 / 0
    end
    return string.byte(self, index + 1) or (0 / 0)
end

function __TS__StringConcat(str1, ...)
    local args = {...}
    local out = str1
    for ____, arg in ipairs(args) do
        out = tostring(out) .. tostring(arg)
    end
    return out
end

function __TS__StringEndsWith(self, searchString, endPosition)
    if (endPosition == nil) or (endPosition > #self) then
        endPosition = #self
    end
    return string.sub(self, (endPosition - #searchString) + 1, endPosition) == searchString
end

function __TS__StringPadEnd(self, maxLength, fillString)
    if fillString == nil then
        fillString = \\" \\"
    end
    if maxLength ~= maxLength then
        maxLength = 0
    end
    if (maxLength == -math.huge) or (maxLength == math.huge) then
        error(\\"Invalid string length\\", 0)
    end
    if (#self >= maxLength) or (#fillString == 0) then
        return self
    end
    maxLength = maxLength - #self
    if maxLength > #fillString then
        fillString = tostring(fillString) .. tostring(
            string.rep(
                fillString,
                math.floor(maxLength / #fillString)
            )
        )
    end
    return tostring(self) .. tostring(
        string.sub(
            fillString,
            1,
            math.floor(maxLength)
        )
    )
end

function __TS__StringPadStart(self, maxLength, fillString)
    if fillString == nil then
        fillString = \\" \\"
    end
    if maxLength ~= maxLength then
        maxLength = 0
    end
    if (maxLength == -math.huge) or (maxLength == math.huge) then
        error(\\"Invalid string length\\", 0)
    end
    if (#self >= maxLength) or (#fillString == 0) then
        return self
    end
    maxLength = maxLength - #self
    if maxLength > #fillString then
        fillString = tostring(fillString) .. tostring(
            string.rep(
                fillString,
                math.floor(maxLength / #fillString)
            )
        )
    end
    return tostring(
        string.sub(
            fillString,
            1,
            math.floor(maxLength)
        )
    ) .. tostring(self)
end

function __TS__StringReplace(source, searchValue, replaceValue)
    searchValue = string.gsub(searchValue, \\"[%%%(%)%.%+%-%*%?%[%^%$]\\", \\"%%%1\\")
    if type(replaceValue) == \\"string\\" then
        replaceValue = string.gsub(replaceValue, \\"%%\\", \\"%%%%\\")
        local result = string.gsub(source, searchValue, replaceValue, 1)
        return result
    else
        local result = string.gsub(
            source,
            searchValue,
            function(match) return replaceValue(_G, match) end,
            1
        )
        return result
    end
end

function __TS__StringSlice(self, start, ____end)
    if (start == nil) or (start ~= start) then
        start = 0
    end
    if ____end ~= ____end then
        ____end = 0
    end
    if start >= 0 then
        start = start + 1
    end
    if (____end ~= nil) and (____end < 0) then
        ____end = ____end - 1
    end
    return string.sub(self, start, ____end)
end

function __TS__StringSplit(source, separator, limit)
    if limit == nil then
        limit = 4294967295
    end
    if limit == 0 then
        return {}
    end
    local out = {}
    local index = 0
    local count = 0
    if (separator == nil) or (separator == \\"\\") then
        while (index < (#source - 1)) and (count < limit) do
            out[count + 1] = __TS__StringAccess(source, index)
            count = count + 1
            index = index + 1
        end
    else
        local separatorLength = #separator
        local nextIndex = (string.find(source, separator, nil, true) or 0) - 1
        while (nextIndex >= 0) and (count < limit) do
            out[count + 1] = __TS__StringSubstring(source, index, nextIndex)
            count = count + 1
            index = nextIndex + separatorLength
            nextIndex = (string.find(
                source,
                separator,
                math.max(index + 1, 1),
                true
            ) or 0) - 1
        end
    end
    if count < limit then
        out[count + 1] = __TS__StringSubstring(source, index)
    end
    return out
end

function __TS__StringStartsWith(self, searchString, position)
    if (position == nil) or (position < 0) then
        position = 0
    end
    return string.sub(self, position + 1, #searchString + position) == searchString
end

function __TS__StringSubstr(self, from, length)
    if from ~= from then
        from = 0
    end
    if length ~= nil then
        if (length ~= length) or (length <= 0) then
            return \\"\\"
        end
        length = length + from
    end
    if from >= 0 then
        from = from + 1
    end
    return string.sub(self, from, length)
end

function __TS__StringSubstring(self, start, ____end)
    if ____end ~= ____end then
        ____end = 0
    end
    if (____end ~= nil) and (start > ____end) then
        start, ____end = __TS__Unpack({____end, start})
    end
    if start >= 0 then
        start = start + 1
    else
        start = 1
    end
    if (____end ~= nil) and (____end < 0) then
        ____end = 0
    end
    return string.sub(self, start, ____end)
end

function __TS__StringTrim(self)
    local result = string.gsub(self, \\"^[%s]*(.-)[%s]*$\\", \\"%1\\")
    return result
end

function __TS__StringTrimEnd(self)
    local result = string.gsub(self, \\"[%s]*$\\", \\"\\")
    return result
end

function __TS__StringTrimStart(self)
    local result = string.gsub(self, \\"^[%s]*\\", \\"\\")
    return result
end

____symbolRegistry = {}
function __TS__SymbolRegistryFor(key)
    if not ____symbolRegistry[key] then
        ____symbolRegistry[key] = __TS__Symbol(key)
    end
    return ____symbolRegistry[key]
end
function __TS__SymbolRegistryKeyFor(sym)
    for key in pairs(____symbolRegistry) do
        if ____symbolRegistry[key] == sym then
            return key
        end
    end
end

function __TS__TypeOf(value)
    local luaType = type(value)
    if luaType == \\"table\\" then
        return \\"object\\"
    elseif luaType == \\"nil\\" then
        return \\"undefined\\"
    else
        return luaType
    end
end

end,
[\\"node_modules.basic-pragma.src.adapter\\"] = function() local ____exports = {}
local function baseCreateFrame()
    error(\\"Adapter has not implemented createFrame\\", 0)
end
local function baseCleanupFrame()
    error(\\"Adapter has not implemented cleanupFrame\\", 0)
end
local function baseUpdateFrameProperties()
    error(\\"Adapter has not implemented updateFrameProperties\\", 0)
end
local function baseGetParent()
    error(\\"Adapter has not implemented getParent\\", 0)
end
local function baseScheduleUpdate()
    error(\\"Adapter has not implemented scheduleUdate\\", 0)
end
local internalAdapter = {createFrame = baseCreateFrame, cleanupFrame = baseCleanupFrame, updateFrameProperties = baseUpdateFrameProperties, getParent = baseGetParent, scheduleUpdate = baseScheduleUpdate}
____exports.adapter = internalAdapter
____exports.setAdapter = function(adapter)
    internalAdapter.createFrame = adapter.createFrame or baseCreateFrame
    internalAdapter.cleanupFrame = adapter.cleanupFrame or baseCleanupFrame
    internalAdapter.getParent = adapter.getParent or baseGetParent
    internalAdapter.updateFrameProperties = adapter.updateFrameProperties or baseUpdateFrameProperties
    internalAdapter.scheduleUpdate = adapter.scheduleUpdate or baseScheduleUpdate
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.common\\"] = function() local ____exports = {}
____exports.TEXT_ELEMENT = \\"TEXT ELEMENT\\"
____exports.isLua = _G._VERSION ~= nil
return ____exports
end,
[\\"node_modules.basic-pragma.src.utils.arrays\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____common = require(\\"node_modules.basic-pragma.src.common\\")
local isLua = ____common.isLua
____exports.getLength = function(____, arr) return (isLua and __TS__ArrayReduce(
    __TS__ObjectKeys(arr),
    function(____, max, key)
        local keyAsNumber = __TS__ParseInt(key)
        if type(keyAsNumber) == \\"number\\" then
            return ((max > keyAsNumber) and max) or keyAsNumber
        end
        return max
    end,
    0
)) or #arr end
____exports.compact = function(____, arr)
    local length = ____exports.getLength(nil, arr)
    local newArr = {}
    do
        local i = 0
        while i < length do
            local val = arr[i + 1]
            if val ~= nil then
                __TS__ArrayPush(newArr, val)
            end
            i = i + 1
        end
    end
    return newArr
end
____exports.forEach = function(____, arr, fn)
    local length = ____exports.getLength(nil, arr)
    do
        local i = 0
        while i < length do
            fn(nil, arr[i + 1], i)
            i = i + 1
        end
    end
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.reconciler\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____adapter = require(\\"node_modules.basic-pragma.src.adapter\\")
local adapter = ____adapter.adapter
local ____element = require(\\"node_modules.basic-pragma.src.element\\")
local isChild = ____element.isChild
local processChildren = ____element.processChildren
local ____common = require(\\"node_modules.basic-pragma.src.common\\")
local isLua = ____common.isLua
local TEXT_ELEMENT = ____common.TEXT_ELEMENT
local ____arrays = require(\\"node_modules.basic-pragma.src.utils.arrays\\")
local compact = ____arrays.compact
local cleanupFrames, reconcileChildren, instantiate, functionalComponentClasses, isClass, createPublicInstance
function ____exports.reconcile(parentFrame, instance, vnode)
    do
        local ____try, err, ____returnValue = pcall(
            function()
                if not instance then
                    if not vnode then
                        return true, nil
                    end
                    return true, instantiate(vnode, parentFrame)
                elseif not vnode then
                    cleanupFrames(instance)
                    return true, nil
                elseif instance.vnode.type ~= vnode.type then
                    local newInstance = instantiate(vnode, parentFrame)
                    cleanupFrames(instance)
                    return true, newInstance
                else
                    local instanceOfSameType = instance
                    if type(vnode.type) == \\"string\\" then
                        adapter:updateFrameProperties(instance.hostFrame, instance.vnode.props, vnode.props)
                        instanceOfSameType.childInstances = reconcileChildren(instanceOfSameType, vnode)
                    elseif instanceOfSameType.component then
                        instanceOfSameType.component.props = vnode.props
                        do
                            local ____try, err = pcall(
                                function()
                                    ____exports.hooks.beforeRender(instanceOfSameType.component)
                                end
                            )
                            if not ____try then
                                print(err)
                                cleanupFrames(instance)
                                error(err, 0)
                            end
                        end
                        local rendered = instanceOfSameType.component:render(vnode.props)
                        local children = (isChild(rendered) and ((rendered and ({rendered})) or ({}))) or rendered
                        instanceOfSameType.childInstances = reconcileChildren(instanceOfSameType, vnode, children)
                    end
                    instanceOfSameType.vnode = vnode
                    return true, instanceOfSameType
                end
            end
        )
        if not ____try then
            err, ____returnValue = (function()
                print(err)
                return true, nil
            end)()
        end
        if err then
            return ____returnValue
        end
    end
end
function cleanupFrames(instance)
    if instance.component then
        ____exports.hooks.beforeUnmount(instance.component)
    end
    if instance.childInstances then
        for ____, child in ipairs(instance.childInstances) do
            if child ~= nil then
                cleanupFrames(child)
            end
        end
    end
    if instance.hostFrame then
        adapter:cleanupFrame(instance.hostFrame)
    end
end
function reconcileChildren(instance, vnode, children)
    if children == nil then
        children = vnode.props.children
    end
    local hostFrame = instance.hostFrame
    local childInstances = instance.childInstances
    local nextChildElements = processChildren(children or ({}))
    local newChildInstances = {}
    local count = math.max(#childInstances, #nextChildElements)
    do
        local i = 0
        while i < count do
            local childInstance = childInstances[i + 1]
            local childElement = nextChildElements[i + 1]
            local newChildInstance = ____exports.reconcile(hostFrame, childInstance, childElement)
            if newChildInstance ~= nil then
                __TS__ArrayPush(newChildInstances, newChildInstance)
            end
            i = i + 1
        end
    end
    return newChildInstances
end
function instantiate(vnode, parentFrame)
    local ____type = vnode.type
    local props = vnode.props
    if type(____type) == \\"string\\" then
        if ____type == TEXT_ELEMENT then
            error(\\"Cannot create inline text, yet\\", 0)
        end
        local frame = adapter:createFrame(____type, parentFrame, props)
        local childElements = processChildren(props.children or ({}))
        local childInstances = __TS__ArrayMap(
            childElements,
            function(____, child) return instantiate(child, frame) end
        )
        local instance = {hostFrame = frame, vnode = vnode, childInstances = childInstances}
        adapter:updateFrameProperties(frame, {}, props)
        return instance
    else
        local instance = {vnode = vnode}
        instance.component = createPublicInstance(vnode, instance)
        do
            local ____try, err = pcall(
                function()
                    ____exports.hooks.beforeRender(instance.component)
                end
            )
            if not ____try then
                print(err)
            end
        end
        local rendered = (function(____lhs)
            if ____lhs == nil then
                return {}
            else
                return ____lhs
            end
        end)(
            instance.component:render(props)
        )
        local childElements = (isChild(rendered) and ({rendered})) or rendered
        instance.childInstances = __TS__ArrayMap(
            __TS__ArrayFilter(
                compact(nil, childElements),
                function(____, child) return type(child) == \\"table\\" end
            ),
            function(____, child) return instantiate(child, parentFrame) end
        )
        return instance
    end
end
function createPublicInstance(vnode, internalInstance)
    local ComponentType = vnode.type
    local props = vnode.props
    local constructor
    if type(ComponentType) == \\"string\\" then
        error(\\"Tried createPublicInstance() with string\\", 0)
    elseif isClass(ComponentType) then
        constructor = ComponentType
    else
        local renderFunc = ComponentType
        local existingClass = functionalComponentClasses:get(renderFunc)
        if existingClass then
            constructor = existingClass
        else
            constructor = (function()
                local ____ = __TS__Class()
                ____.name = ____.name
                __TS__ClassExtends(____, ____exports.ClassComponent)
                function ____.prototype.render(self, props)
                    return renderFunc(props)
                end
                return ____
            end)()
            functionalComponentClasses:set(renderFunc, constructor)
        end
    end
    local publicInstance = __TS__New(constructor, props)
    publicInstance.instance = internalInstance
    return publicInstance
end
____exports.hooks = {
    beforeRender = function(instance)
    end,
    beforeUnmount = function(instance)
    end
}
local containerMap = __TS__New(WeakMap)
function ____exports.render(vnode, container)
    local prevInstance = containerMap:get(container) or nil
    local nextInstance = ____exports.reconcile(container, prevInstance, vnode)
    containerMap:set(containerMap, nextInstance)
end
functionalComponentClasses = __TS__New(WeakMap)
isClass = function(constructor)
    if isLua then
        return type(constructor) ~= \\"function\\"
    else
        return constructor.prototype ~= nil
    end
end
local instanceMap = __TS__New(WeakMap)
local scheduledUpdates = __TS__New(Set)
local function scheduleUpdate(instance)
    scheduledUpdates:add(instance)
    adapter:scheduleUpdate()
end
____exports.ClassComponent = __TS__Class()
local ClassComponent = ____exports.ClassComponent
ClassComponent.name = \\"ClassComponent\\"
function ClassComponent.prototype.____constructor(self, props)
    self.props = props
    self.state = {}
end
__TS__SetDescriptor(
    ClassComponent.prototype,
    \\"instance\\",
    {
        set = function(self, instance)
            instanceMap:set(self, instance)
        end
    },
    true
)
function ClassComponent.prototype.setState(self, partialState)
    self.state = __TS__ObjectAssign({}, self.state, partialState)
    local instance = instanceMap:get(self)
    if instance then
        scheduleUpdate(instance)
    end
end
local function updateInstance(internalInstance)
    local vnode = internalInstance.vnode
    ____exports.reconcile(nil, internalInstance, vnode)
end
____exports.flushUpdates = function()
    for ____, instance in __TS__Iterator(
        scheduledUpdates:values()
    ) do
        updateInstance(instance)
    end
    scheduledUpdates:clear()
end
____exports.test = {functionalComponentClasses = functionalComponentClasses}
return ____exports
end,
[\\"node_modules.basic-pragma.src.Component\\"] = function() local ____exports = {}
return ____exports
end,
[\\"node_modules.basic-pragma.src.element\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____common = require(\\"node_modules.basic-pragma.src.common\\")
local TEXT_ELEMENT = ____common.TEXT_ELEMENT
local ____arrays = require(\\"node_modules.basic-pragma.src.utils.arrays\\")
local compact = ____arrays.compact
local getLength = ____arrays.getLength
local createTextElement
function ____exports.createElement(____type, config, children)
    local ____ = __TS__ObjectAssign({}, config)
    local key = ____.key
    if key == nil then
        key = nil
    end
    local props = __TS__ObjectRest(____, {key = true, props = true})
    local flattenedChildren = ____exports.processChildren(
        ((children and (getLength(nil, children) > 0)) and children) or ({})
    )
    if #flattenedChildren > 0 then
        props.children = flattenedChildren
    else
        __TS__Delete(props, \\"children\\")
    end
    local vnode = {type = ____type, props = props}
    if key ~= nil then
        vnode.key = key
    end
    return vnode
end
function createTextElement(value)
    return ____exports.createElement(TEXT_ELEMENT, {nodeValue = value})
end
____exports.isChild = function(obj) return (((((type(obj) == \\"table\\") and (obj ~= nil)) and (obj.type ~= nil)) and (obj.props ~= nil)) or (type(obj) == \\"boolean\\")) or (type(obj) == \\"string\\") end
____exports.processChildren = function(children) return __TS__ArrayMap(
    __TS__ArrayFilter(
        compact(
            nil,
            __TS__ArrayFlat(
                compact(nil, children)
            )
        ),
        function(____, c) return (type(c) ~= \\"boolean\\") and ((type(c) == \\"string\\") or (not (not c.type))) end
    ),
    function(____, c) return ((type(c) == \\"string\\") and createTextElement(c)) or c end
) end
local EMPTY_OBJECT = {}
____exports.Fragment = function(____bindingPattern0)
    local children
    children = ____bindingPattern0.children
    return children or nil
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.types\\"] = function() local ____exports = {}
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.context\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
____exports.hookContext = {}
____exports.hookMap = __TS__New(WeakMap)
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.reconcilerHooks\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____reconciler = require(\\"node_modules.basic-pragma.src.reconciler\\")
local hooks = ____reconciler.hooks
local ____context = require(\\"node_modules.basic-pragma.src.hooks.context\\")
local hookContext = ____context.hookContext
local hookMap = ____context.hookMap
local oldBeforeRender = hooks.beforeRender
local oldBeforeUnmount = hooks.beforeUnmount
hooks.beforeRender = function(instance)
    oldBeforeRender(instance)
    hookContext.currentInstance = instance
    hookContext.currentIndex = 0
    if not hookMap:has(instance) then
        hookMap:set(instance, {})
    end
end
hooks.beforeUnmount = function(instance)
    oldBeforeUnmount(instance)
    local hooks = hookMap:get(instance)
    if hooks then
        __TS__ArrayForEach(
            hooks,
            function(____, hook) return ((hook.type == \\"effect\\") and hook.cleanup) and hook.cleanup() end
        )
    end
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.useReducer\\"] = function() local ____exports = {}
local ____context = require(\\"node_modules.basic-pragma.src.hooks.context\\")
local hookContext = ____context.hookContext
local hookMap = ____context.hookMap
require(\\"node_modules.basic-pragma.src.hooks.reconcilerHooks\\")
____exports.useReducer = function(reducer, initialState)
    local index = (function()
        local ____tmp = hookContext.currentIndex
        hookContext.currentIndex = ____tmp + 1
        return ____tmp
    end)()
    local hooks = hookMap:get(hookContext.currentInstance)
    local state = hooks[index + 1] or (function(o, i, v)
        o[i] = v
        return v
    end)(hooks, index + 1, {type = \\"reducer\\"})
    if state.type ~= \\"reducer\\" then
        error(
            ((\\"Expected a reducer hook at index \\" .. tostring(index)) .. \\", got \\") .. tostring(state.type),
            0
        )
    end
    state.reducer = reducer
    if not state.instance then
        state.value = {
            initialState,
            function(action)
                local nextValue = state.reducer(state.value[1], action)
                if state.value[1] ~= nextValue then
                    state.value = {nextValue, state.value[2]}
                    state.instance:setState({})
                end
            end
        }
        state.instance = hookContext.currentInstance
    end
    return state.value
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.useState\\"] = function() local ____exports = {}
local ____useReducer = require(\\"node_modules.basic-pragma.src.hooks.useReducer\\")
local useReducer = ____useReducer.useReducer
____exports.useState = function(initialState) return useReducer(
    function(oldState, v)
        if type(v) ~= \\"function\\" then
            return v
        end
        return v(oldState)
    end,
    initialState
) end
____exports.useForceUpdate = function()
    local ____, setTick = table.unpack(
        ____exports.useState(0)
    )
    local function update()
        setTick(
            function(tick) return tick + 1 end
        )
    end
    return update
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.helpers\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
____exports.argsChanged = function(oldArgs, newArgs) return (#oldArgs ~= #newArgs) or __TS__ArraySome(
    newArgs,
    function(____, arg, index) return arg ~= oldArgs[index + 1] end
) end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.useEffect\\"] = function() local ____exports = {}
local ____context = require(\\"node_modules.basic-pragma.src.hooks.context\\")
local hookContext = ____context.hookContext
local hookMap = ____context.hookMap
local ____helpers = require(\\"node_modules.basic-pragma.src.hooks.helpers\\")
local argsChanged = ____helpers.argsChanged
require(\\"node_modules.basic-pragma.src.hooks.reconcilerHooks\\")
____exports.useEffect = function(callback, inputs)
    local index = (function()
        local ____tmp = hookContext.currentIndex
        hookContext.currentIndex = ____tmp + 1
        return ____tmp
    end)()
    local hooks = hookMap:get(hookContext.currentInstance)
    local oldState = hooks[index + 1]
    local state = oldState or (function(o, i, v)
        o[i] = v
        return v
    end)(hooks, index + 1, {type = \\"effect\\"})
    if state.type ~= \\"effect\\" then
        error(
            ((\\"Expected an effect hook at index \\" .. tostring(index)) .. \\", got \\") .. tostring(state.type),
            0
        )
    end
    if (not oldState) or ((state.lastInputs and inputs) and argsChanged(state.lastInputs, inputs)) then
        if state.cleanup then
            state.cleanup()
        end
        state.lastInputs = inputs
        state.cleanup = callback()
    end
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.hooks.useRef\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____context = require(\\"node_modules.basic-pragma.src.hooks.context\\")
local hookContext = ____context.hookContext
local hookMap = ____context.hookMap
require(\\"node_modules.basic-pragma.src.hooks.reconcilerHooks\\")
local function initializeRef(initial)
    local state = {type = \\"ref\\", current = initial}
    __TS__ObjectDefineProperty(state, \\"type\\", {enumerable = false, value = \\"ref\\"})
    return state
end
____exports.useRef = function(initial)
    local index = (function()
        local ____tmp = hookContext.currentIndex
        hookContext.currentIndex = ____tmp + 1
        return ____tmp
    end)()
    local hooks = hookMap:get(hookContext.currentInstance)
    local state = hooks[index + 1] or (function(o, i, v)
        o[i] = v
        return v
    end)(
        hooks,
        index + 1,
        initializeRef(initial)
    )
    if state.type ~= \\"ref\\" then
        error(
            ((\\"Expected a ref hook at index \\" .. tostring(index)) .. \\", got \\") .. tostring(state.type),
            0
        )
    end
    return state
end
return ____exports
end,
[\\"node_modules.basic-pragma.src.index\\"] = function() local ____exports = {}
do
    local ____adapter = require(\\"node_modules.basic-pragma.src.adapter\\")
    local setAdapter = ____adapter.setAdapter
    ____exports.setAdapter = setAdapter
end
do
    local ____element = require(\\"node_modules.basic-pragma.src.element\\")
    local createElement = ____element.createElement
    local Fragment = ____element.Fragment
    ____exports.createElement = createElement
    ____exports.Fragment = Fragment
end
do
    local ____reconciler = require(\\"node_modules.basic-pragma.src.reconciler\\")
    local render = ____reconciler.render
    local flushUpdates = ____reconciler.flushUpdates
    ____exports.render = render
    ____exports.flushUpdates = flushUpdates
end
do
    local ____useReducer = require(\\"node_modules.basic-pragma.src.hooks.useReducer\\")
    local useReducer = ____useReducer.useReducer
    ____exports.useReducer = useReducer
end
do
    local ____useState = require(\\"node_modules.basic-pragma.src.hooks.useState\\")
    local useState = ____useState.useState
    local useForceUpdate = ____useState.useForceUpdate
    ____exports.useState = useState
    ____exports.useForceUpdate = useForceUpdate
end
do
    local ____useEffect = require(\\"node_modules.basic-pragma.src.hooks.useEffect\\")
    local useEffect = ____useEffect.useEffect
    ____exports.useEffect = useEffect
end
do
    local ____useRef = require(\\"node_modules.basic-pragma.src.hooks.useRef\\")
    local useRef = ____useRef.useRef
    ____exports.useRef = useRef
end
return ____exports
end,
[\\"src.adapter\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____index = require(\\"node_modules.basic-pragma.src.index\\")
local flushUpdates = ____index.flushUpdates
local render = ____index.render
local frameDefaults = {name = \\"AnonymousFrame\\", priority = 0, isSimple = true, typeName = nil, inherits = \\"\\", context = 0, key = nil, alpha = 255, enabled = true, font = {fileName = \\"\\", height = 16, flags = 0}, level = 0, maxLength = 9999, minMaxValue = {min = -999999999, max = 999999999}, model = {modelFile = \\"\\", cameraIndex = 0}, scale = 1, spriteAnimate = {primaryProp = 0, flags = 0}, stepSize = 0, text = \\"\\", textAlignment = {vert = TEXT_JUSTIFY_TOP, horz = TEXT_JUSTIFY_LEFT}, textColor = 16777215, texture = {texFile = \\"\\", flag = 0, blend = true}, tooltip = nil, value = 0, vertexColor = 16777215, visible = true, position = nil, absPosition = nil, size = {width = 0, height = 0}, children = nil, ref = nil, onClick = nil, onMouseEnter = nil, onMouseLeave = nil, onMouseUp = nil, onMouseDown = nil, onMouseWheel = nil, onCheckboxChecked = nil, onCheckboxUnchecked = nil, onEditboxTextChanged = nil, onPopupmenuItemChanged = nil, onDoubleClick = nil, onSpriteAnimUpdate = nil, onSliderChanged = nil, onDialogCancel = nil, onDialogAccept = nil, onEditboxEnter = nil}
local ____ = frameDefaults
local function absurd(value)
    error(
        (\\"Got \\" .. tostring(value)) .. \\" when expected nothing\\",
        0
    )
end
local triggerMap = __TS__New(WeakMap)
local function setEventProp(frame, event, val, oldValue)
    local t = triggerMap:get(oldValue)
    if val == nil then
        if t then
            DestroyTrigger(t)
            triggerMap:delete(oldValue)
        end
        return
    end
    if t == nil then
        t = CreateTrigger()
        BlzTriggerRegisterFrameEvent(t, frame, event)
    else
        TriggerClearConditions(t)
    end
    TriggerAddCondition(
        t,
        Condition(
            function()
                if event == FRAMEEVENT_CONTROL_CLICK then
                    BlzFrameSetEnable(frame, false)
                    BlzFrameSetEnable(frame, true)
                end
                val()
                return false
            end
        )
    )
    triggerMap:set(val, t)
end
local firstChildRelativePoints = {FRAMEPOINT_TOPLEFT, FRAMEPOINT_TOP, FRAMEPOINT_LEFT}
local lastChildRelativePoints = {FRAMEPOINT_RIGHT, FRAMEPOINT_BOTTOM, FRAMEPOINT_BOTTOMRIGHT}
local function resolveRelative(frame, relative, relativePoint)
    if type(relative) ~= \\"string\\" then
        return relative
    end
    local ____switch12 = relative
    if ____switch12 == \\"parent\\" then
        goto ____switch12_case_0
    elseif ____switch12 == \\"previous\\" then
        goto ____switch12_case_1
    elseif ____switch12 == \\"children\\" then
        goto ____switch12_case_2
    elseif ____switch12 == \\"children-reverse\\" then
        goto ____switch12_case_3
    end
    goto ____switch12_case_default
    ::____switch12_case_0::
    do
        return BlzFrameGetParent(frame)
    end
    ::____switch12_case_1::
    do
        do
            local parent = BlzFrameGetParent(frame)
            local children = BlzFrameGetChildrenCount(parent)
            local index = -1
            do
                local i = 0
                while i < children do
                    if BlzFrameGetChild(parent, i) == frame then
                        index = i
                        break
                    end
                    i = i + 1
                end
            end
            if index > 0 then
                return BlzFrameGetChild(parent, index - 1)
            end
            return nil
        end
    end
    ::____switch12_case_2::
    do
        if __TS__ArrayIncludes(firstChildRelativePoints, relativePoint) then
            return BlzFrameGetChild(frame, 0)
        end
        if __TS__ArrayIncludes(lastChildRelativePoints, relativePoint) then
            return BlzFrameGetChild(
                frame,
                BlzFrameGetChildrenCount(frame) - 1
            )
        end
        error(
            ((\\"When using relative=children, expected relativePoint to be in \\" .. tostring(firstChildRelativePoints)) .. \\" or \\") .. tostring(lastChildRelativePoints),
            0
        )
    end
    ::____switch12_case_3::
    do
        if __TS__ArrayIncludes(lastChildRelativePoints, relativePoint) then
            return BlzFrameGetChild(frame, 0)
        end
        if __TS__ArrayIncludes(firstChildRelativePoints, relativePoint) then
            return BlzFrameGetChild(
                frame,
                BlzFrameGetChildrenCount(frame) - 1
            )
        end
        error(
            ((\\"When using relative=children, expected relativePoint to be in \\" .. tostring(firstChildRelativePoints)) .. \\" or \\") .. tostring(lastChildRelativePoints),
            0
        )
    end
    ::____switch12_case_default::
    do
        absurd(relative)
    end
    ::____switch12_end::
end
local function previousToParentPoint(relative)
    local ____switch22 = relative
    if ____switch22 == FRAMEPOINT_RIGHT then
        goto ____switch22_case_0
    elseif ____switch22 == FRAMEPOINT_BOTTOM then
        goto ____switch22_case_1
    elseif ____switch22 == FRAMEPOINT_BOTTOMLEFT then
        goto ____switch22_case_2
    elseif ____switch22 == FRAMEPOINT_BOTTOMRIGHT then
        goto ____switch22_case_3
    end
    goto ____switch22_end
    ::____switch22_case_0::
    do
        return FRAMEPOINT_LEFT
    end
    ::____switch22_case_1::
    do
        return FRAMEPOINT_TOP
    end
    ::____switch22_case_2::
    do
        return FRAMEPOINT_TOPLEFT
    end
    ::____switch22_case_3::
    do
        return FRAMEPOINT_TOPRIGHT
    end
    ::____switch22_end::
end
local tooltipMap = __TS__New(WeakMap)
local scale = 1600 * 1.25
____exports.setPixelScale = function(newScale)
    scale = newScale * 1.25
end
local function smartSize(size)
    return (((size < 1) and (size > -1)) and size) or (size / scale)
end
local function setProp(frame, prop, value, oldValue)
    local val = (function(____lhs)
        if ____lhs == nil then
            return frameDefaults[prop]
        else
            return ____lhs
        end
    end)(value)
    local _oldValue = oldValue
    local ____switch26 = prop
    if ____switch26 == \\"text\\" then
        goto ____switch26_case_0
    elseif ____switch26 == \\"maxLength\\" then
        goto ____switch26_case_1
    elseif ____switch26 == \\"textColor\\" then
        goto ____switch26_case_2
    elseif ____switch26 == \\"texture\\" then
        goto ____switch26_case_3
    elseif ____switch26 == \\"model\\" then
        goto ____switch26_case_4
    elseif ____switch26 == \\"alpha\\" then
        goto ____switch26_case_5
    elseif ____switch26 == \\"level\\" then
        goto ____switch26_case_6
    elseif ____switch26 == \\"visible\\" then
        goto ____switch26_case_7
    elseif ____switch26 == \\"enabled\\" then
        goto ____switch26_case_8
    elseif ____switch26 == \\"vertexColor\\" then
        goto ____switch26_case_9
    elseif ____switch26 == \\"value\\" then
        goto ____switch26_case_10
    elseif ____switch26 == \\"size\\" then
        goto ____switch26_case_11
    elseif ____switch26 == \\"stepSize\\" then
        goto ____switch26_case_12
    elseif ____switch26 == \\"tooltip\\" then
        goto ____switch26_case_13
    elseif ____switch26 == \\"font\\" then
        goto ____switch26_case_14
    elseif ____switch26 == \\"minMaxValue\\" then
        goto ____switch26_case_15
    elseif ____switch26 == \\"scale\\" then
        goto ____switch26_case_16
    elseif ____switch26 == \\"spriteAnimate\\" then
        goto ____switch26_case_17
    elseif ____switch26 == \\"textAlignment\\" then
        goto ____switch26_case_18
    elseif ____switch26 == \\"position\\" then
        goto ____switch26_case_19
    elseif ____switch26 == \\"absPosition\\" then
        goto ____switch26_case_20
    elseif ____switch26 == \\"onClick\\" then
        goto ____switch26_case_21
    elseif ____switch26 == \\"onMouseEnter\\" then
        goto ____switch26_case_22
    elseif ____switch26 == \\"onMouseLeave\\" then
        goto ____switch26_case_23
    elseif ____switch26 == \\"onMouseUp\\" then
        goto ____switch26_case_24
    elseif ____switch26 == \\"onMouseDown\\" then
        goto ____switch26_case_25
    elseif ____switch26 == \\"onMouseWheel\\" then
        goto ____switch26_case_26
    elseif ____switch26 == \\"onCheckboxChecked\\" then
        goto ____switch26_case_27
    elseif ____switch26 == \\"onCheckboxUnchecked\\" then
        goto ____switch26_case_28
    elseif ____switch26 == \\"onEditboxTextChanged\\" then
        goto ____switch26_case_29
    elseif ____switch26 == \\"onPopupmenuItemChanged\\" then
        goto ____switch26_case_30
    elseif ____switch26 == \\"onDoubleClick\\" then
        goto ____switch26_case_31
    elseif ____switch26 == \\"onSpriteAnimUpdate\\" then
        goto ____switch26_case_32
    elseif ____switch26 == \\"onSliderChanged\\" then
        goto ____switch26_case_33
    elseif ____switch26 == \\"onDialogCancel\\" then
        goto ____switch26_case_34
    elseif ____switch26 == \\"onDialogAccept\\" then
        goto ____switch26_case_35
    elseif ____switch26 == \\"onEditboxEnter\\" then
        goto ____switch26_case_36
    elseif ____switch26 == \\"ref\\" then
        goto ____switch26_case_37
    elseif ____switch26 == \\"name\\" then
        goto ____switch26_case_38
    elseif ____switch26 == \\"priority\\" then
        goto ____switch26_case_39
    elseif ____switch26 == \\"isSimple\\" then
        goto ____switch26_case_40
    elseif ____switch26 == \\"typeName\\" then
        goto ____switch26_case_41
    elseif ____switch26 == \\"inherits\\" then
        goto ____switch26_case_42
    elseif ____switch26 == \\"children\\" then
        goto ____switch26_case_43
    elseif ____switch26 == \\"context\\" then
        goto ____switch26_case_44
    elseif ____switch26 == \\"key\\" then
        goto ____switch26_case_45
    end
    goto ____switch26_case_default
    ::____switch26_case_0::
    do
        do
            BlzFrameSetText(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_1::
    do
        do
            BlzFrameSetTextSizeLimit(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_2::
    do
        do
            BlzFrameSetTextColor(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_3::
    do
        do
            local val2 = ((type(val) == \\"string\\") and ({texFile = val})) or val
            BlzFrameSetTexture(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.texture.texFile
                    else
                        return ____lhs
                    end
                end)(val2.texFile),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.texture.flag
                    else
                        return ____lhs
                    end
                end)(val2.flag),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.texture.blend
                    else
                        return ____lhs
                    end
                end)(val2.blend)
            )
            goto ____switch26_end
        end
    end
    ::____switch26_case_4::
    do
        do
            BlzFrameSetModel(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.model.modelFile
                    else
                        return ____lhs
                    end
                end)(val.modelFile),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.model.cameraIndex
                    else
                        return ____lhs
                    end
                end)(val.cameraIndex)
            )
            goto ____switch26_end
        end
    end
    ::____switch26_case_5::
    do
        do
            BlzFrameSetAlpha(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_6::
    do
        do
            BlzFrameSetLevel(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_7::
    do
        do
            BlzFrameSetVisible(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_8::
    do
        do
            BlzFrameSetEnable(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_9::
    do
        do
            BlzFrameSetVertexColor(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_10::
    do
        do
            BlzFrameSetValue(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_11::
    do
        do
            BlzFrameSetSize(
                frame,
                smartSize(
                    (function(____lhs)
                        if ____lhs == nil then
                            return frameDefaults.size.width
                        else
                            return ____lhs
                        end
                    end)(val.width)
                ),
                smartSize(
                    (function(____lhs)
                        if ____lhs == nil then
                            return frameDefaults.size.height
                        else
                            return ____lhs
                        end
                    end)(val.height)
                )
            )
            goto ____switch26_end
        end
    end
    ::____switch26_case_12::
    do
        do
            BlzFrameSetStepSize(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_13::
    do
        do
            local existingTooltip = tooltipMap:get(frame)
            local tooltip
            if existingTooltip then
                tooltip = existingTooltip
            else
                tooltip = ____exports.adapter:createFrame(
                    \\"container\\",
                    BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0),
                    {name = \\"Tooltip\\"}
                )
                tooltipMap:set(frame, tooltip)
                BlzFrameSetTooltip(frame, tooltip)
            end
            render(val, tooltip)
            goto ____switch26_end
        end
    end
    ::____switch26_case_14::
    do
        do
            BlzFrameSetFont(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.font.fileName
                    else
                        return ____lhs
                    end
                end)(val.fileName),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.font.height
                    else
                        return ____lhs
                    end
                end)(val.height),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.font.flags
                    else
                        return ____lhs
                    end
                end)(val.flags)
            )
            goto ____switch26_end
        end
    end
    ::____switch26_case_15::
    do
        do
            BlzFrameSetMinMaxValue(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.minMaxValue.min
                    else
                        return ____lhs
                    end
                end)(val.min),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.minMaxValue.max
                    else
                        return ____lhs
                    end
                end)(val.max)
            )
            goto ____switch26_end
        end
    end
    ::____switch26_case_16::
    do
        do
            BlzFrameSetScale(frame, val)
            goto ____switch26_end
        end
    end
    ::____switch26_case_17::
    do
        do
            BlzFrameSetSpriteAnimate(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.spriteAnimate.primaryProp
                    else
                        return ____lhs
                    end
                end)(val.primaryProp),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.spriteAnimate.flags
                    else
                        return ____lhs
                    end
                end)(val.flags)
            )
            goto ____switch26_end
        end
    end
    ::____switch26_case_18::
    do
        do
            BlzFrameSetTextAlignment(
                frame,
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.textAlignment.vert
                    else
                        return ____lhs
                    end
                end)(val.vert),
                (function(____lhs)
                    if ____lhs == nil then
                        return frameDefaults.textAlignment.horz
                    else
                        return ____lhs
                    end
                end)(val.horz)
            )
            goto ____switch26_end
        end
    end
    ::____switch26_case_19::
    do
        do
            if val ~= nil then
                local positions = ((((val == \\"parent\\") or (val == \\"clear\\")) or (val.point ~= nil)) and ({val})) or val
                for ____, position in ipairs(positions) do
                    if position == \\"clear\\" then
                        BlzFrameClearAllPoints(frame)
                    elseif position == \\"parent\\" then
                        BlzFrameSetAllPoints(
                            frame,
                            BlzFrameGetParent(frame)
                        )
                    else
                        local relative = resolveRelative(frame, position.relative, position.relativePoint)
                        if relative then
                            BlzFrameSetPoint(
                                frame,
                                position.point,
                                relative,
                                position.relativePoint,
                                smartSize(position.x or 0),
                                smartSize(position.y or 0)
                            )
                        else
                            local parentRelative = previousToParentPoint(position.relativePoint)
                            if parentRelative then
                                BlzFrameSetPoint(
                                    frame,
                                    position.point,
                                    BlzFrameGetParent(frame),
                                    parentRelative,
                                    smartSize(position.x or 0),
                                    smartSize(position.y or 0)
                                )
                            end
                        end
                    end
                end
            end
            goto ____switch26_end
        end
    end
    ::____switch26_case_20::
    do
        do
            if val ~= nil then
                local positions = (((val == \\"clear\\") or (val.point ~= nil)) and ({val})) or val
                for ____, absPosition in ipairs(positions) do
                    if absPosition == \\"clear\\" then
                        BlzFrameClearAllPoints(frame)
                    else
                        BlzFrameSetAbsPoint(
                            frame,
                            absPosition.point,
                            smartSize(absPosition.x or 0),
                            smartSize(absPosition.y or 0)
                        )
                    end
                end
            end
            goto ____switch26_end
        end
    end
    ::____switch26_case_21::
    do
        do
            setEventProp(frame, FRAMEEVENT_CONTROL_CLICK, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_22::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_ENTER, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_23::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_LEAVE, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_24::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_UP, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_25::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_DOWN, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_26::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_WHEEL, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_27::
    do
        do
            setEventProp(frame, FRAMEEVENT_CHECKBOX_CHECKED, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_28::
    do
        do
            setEventProp(frame, FRAMEEVENT_CHECKBOX_UNCHECKED, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_29::
    do
        do
            setEventProp(frame, FRAMEEVENT_EDITBOX_TEXT_CHANGED, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_30::
    do
        do
            setEventProp(frame, FRAMEEVENT_POPUPMENU_ITEM_CHANGED, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_31::
    do
        do
            setEventProp(frame, FRAMEEVENT_MOUSE_DOUBLECLICK, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_32::
    do
        do
            setEventProp(frame, FRAMEEVENT_SPRITE_ANIM_UPDATE, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_33::
    do
        do
            setEventProp(frame, FRAMEEVENT_SLIDER_VALUE_CHANGED, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_34::
    do
        do
            setEventProp(frame, FRAMEEVENT_DIALOG_CANCEL, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_35::
    do
        do
            setEventProp(frame, FRAMEEVENT_DIALOG_ACCEPT, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_36::
    do
        do
            setEventProp(frame, FRAMEEVENT_EDITBOX_ENTER, val, _oldValue)
            goto ____switch26_end
        end
    end
    ::____switch26_case_37::
    do
        do
            if val then
                val.current = frame
            end
            goto ____switch26_end
        end
    end
    ::____switch26_case_38::
    do
    end
    ::____switch26_case_39::
    do
    end
    ::____switch26_case_40::
    do
    end
    ::____switch26_case_41::
    do
    end
    ::____switch26_case_42::
    do
    end
    ::____switch26_case_43::
    do
    end
    ::____switch26_case_44::
    do
    end
    ::____switch26_case_45::
    do
        goto ____switch26_end
    end
    ::____switch26_case_default::
    do
        absurd(prop)
    end
    ::____switch26_end::
end
local typeNames = {\\"backdrop\\", \\"button\\", \\"chatdisplay\\", \\"checkbox\\", \\"control\\", \\"dialog\\", \\"editbox\\", \\"gluebutton\\", \\"gluecheckbox\\", \\"glueeditbox\\", \\"gluepopupmenu\\", \\"gluetextbutton\\", \\"highlight\\", \\"listbox\\", \\"menu\\", \\"model\\", \\"popupmenu\\", \\"scrollbar\\", \\"slashchatbox\\", \\"slider\\", \\"sprite\\", \\"text\\", \\"textarea\\", \\"textbutton\\", \\"timertext\\"}
local simpleTypeNames = {\\"simple-button\\", \\"simple-checkbox\\", \\"simple-statusbar\\"}
local updateScheduled = false
local schedulingTimer = CreateTimer()
____exports.adapter = {
    createFrame = function(____, jsxType, parentFrame, props)
        if not parentFrame then
            error(
                \\"expected parent frame for \\" .. tostring(jsxType),
                0
            )
        end
        local name = props.name
        if name == nil then
            name = frameDefaults.name
        end
        local priority = props.priority
        if priority == nil then
            priority = frameDefaults.priority
        end
        local inherits = props.inherits
        local isSimple = props.isSimple
        local context = props.context
        if context == nil then
            context = frameDefaults.context
        end
        local ref = props.ref
        local typeName = props.typeName
        if (typeName == nil) and __TS__ArrayIncludes(typeNames, jsxType) then
            typeName = string.upper(jsxType)
        end
        if (typeName == nil) and __TS__ArrayIncludes(simpleTypeNames, jsxType) then
            typeName = string.upper(
                __TS__StringReplace(jsxType, \\"-\\", \\"\\")
            )
        end
        if (typeName == nil) and (jsxType == \\"container\\") then
            typeName = \\"FRAME\\"
        end
        if (typeName == nil) and (jsxType == \\"simple-container\\") then
            typeName = \\"SIMPLEFRAME\\"
        end
        local frame
        if (function(____lhs)
            if ____lhs == nil then
                return jsxType == \\"simple-frame\\"
            else
                return ____lhs
            end
        end)(isSimple) then
            frame = BlzCreateSimpleFrame(name, parentFrame, context)
        elseif typeName then
            frame = BlzCreateFrameByType(typeName, name, parentFrame, inherits or \\"\\", context)
        else
            frame = BlzCreateFrame(name, parentFrame, priority, context)
        end
        if ref then
            ref.current = frame
        end
        return frame
    end,
    cleanupFrame = function(____, frame)
        BlzDestroyFrame(frame)
        local existingTooltip = tooltipMap:get(frame)
        if existingTooltip then
            ____exports.adapter:cleanupFrame(existingTooltip)
        end
    end,
    updateFrameProperties = function(____, frame, prevProps, nextProps)
        local prop
        for ____value in pairs(prevProps) do
            prop = ____value
            if not (nextProps[prop] ~= nil) then
                do
                    local ____try, err = pcall(
                        function()
                            setProp(frame, prop)
                        end
                    )
                    if not ____try then
                        print(err)
                    end
                end
            end
        end
        for ____value in pairs(nextProps) do
            prop = ____value
            if nextProps[prop] ~= prevProps[prop] then
                do
                    local ____try, err = pcall(
                        function()
                            setProp(frame, prop, nextProps[prop], prevProps[prop])
                        end
                    )
                    if not ____try then
                        print(err)
                    end
                end
            end
        end
    end,
    getParent = function(____, frame) return BlzFrameGetParent(frame) end,
    scheduleUpdate = function()
        if updateScheduled then
            return
        end
        updateScheduled = true
        TimerStart(
            schedulingTimer,
            0,
            false,
            function()
                updateScheduled = false
                flushUpdates()
            end
        )
    end
}
return ____exports
end,
[\\"src.index\\"] = function() local ____exports = {}
local ____adapter = require(\\"src.adapter\\")
local adapter = ____adapter.adapter
local ____index = require(\\"node_modules.basic-pragma.src.index\\")
local setAdapter = ____index.setAdapter
setAdapter(adapter)
do
    local ____adapter = require(\\"src.adapter\\")
    local setPixelScale = ____adapter.setPixelScale
    ____exports.setPixelScale = setPixelScale
end
do
    local ____index = require(\\"node_modules.basic-pragma.src.index\\")
    local createElement = ____index.createElement
    local Fragment = ____index.Fragment
    local render = ____index.render
    local useEffect = ____index.useEffect
    local useForceUpdate = ____index.useForceUpdate
    local useRef = ____index.useRef
    local useState = ____index.useState
    ____exports.createElement = createElement
    ____exports.Fragment = Fragment
    ____exports.render = render
    ____exports.useEffect = useEffect
    ____exports.useForceUpdate = useForceUpdate
    ____exports.useRef = useRef
    ____exports.useState = useState
end
return ____exports
end,
[\\"src.test.integration.sample\\"] = function() local ____exports = {}
local React = require(\\"src.index\\")
local function App()
    return React.createElement(
        React.Fragment,
        null,
        {
            React.createElement(\\"frame\\", {name = \\"GLUETEXTBUTTON\\"}),
            React.createElement(\\"frame\\", {}),
            nil
        }
    )
end
React.render(
    React.createElement(App, {}),
    BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0)
)
return ____exports
end,
[\\"node_modules.basic-pragma.src.utils.colorize\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
____exports.hex = {mana = 12835839, health = 65280, healthHigh = 65280}
local color = {red = \\"|cffff0303\\", blue = \\"|cff0042ff\\", teal = \\"|cff1ce6b9\\", purple = \\"|cff540081\\", yellow = \\"|cfffffc00\\", orange = \\"|cfffe8a0e\\", green = \\"|cff20c000\\", pink = \\"|cffe55bb0\\", gray = \\"|cff959697\\", lightblue = \\"|cff7ebff1\\", darkgreen = \\"|cff106246\\", brown = \\"|cff4a2a04\\", maroon = \\"|cff9b0000\\", navy = \\"|cff0000c3\\", turquoise = \\"|cff00eaff\\", violet = \\"|cffbe00fe\\", wheat = \\"|cffebcd87\\", peach = \\"|cfff8a48b\\", mint = \\"|cffbfff80\\", lavender = \\"|cffdcb9eb\\", coal = \\"|cff282828\\", snow = \\"|cffebf0ff\\", emerald = \\"|cff00781e\\", peanut = \\"|cffa46f33\\", sheepblue = \\"|CFF3F81F8\\", wolfred = \\"|CFFC00040\\", gold = \\"|CFFD9D919\\", string = \\"|cffce915b\\", number = \\"|cffdcdc8b\\", boolean = \\"|cff569cd6\\", white = \\"|cffffffff\\", handle = \\"|cff7ebff1\\"}
____exports.colorize = {}
__TS__ArrayForEach(
    __TS__ObjectEntries(color),
    function(____, ____bindingPattern0)
        local color
        color = ____bindingPattern0[1]
        local code
        code = ____bindingPattern0[2]
        return (function(o, i, v)
            o[i] = v
            return v
        end)(
            ____exports.colorize,
            color,
            function(____string) return (tostring(code) .. tostring(____string)) .. \\"|r\\" end
        )
    end
)
return ____exports
end,
[\\"node_modules.basic-pragma.src.utils.log\\"] = function() require(\\"lualib_bundle\\");
local ____exports = {}
local ____colorize = require(\\"node_modules.basic-pragma.src.utils.colorize\\")
local colorize = ____colorize.colorize
local MAX_WIDTH = 78
local TRAILING_COMMA = false
local INDENT = \\"  \\"
local INDENT_WIDTH = #INDENT
local function isArray(v)
    if type(v) ~= \\"table\\" then
        return false
    end
    return __TS__ArrayEvery(
        __TS__ObjectKeys(v),
        function(____, v, index) return (__TS__ParseInt(v) == (index + 1)) or (__TS__ParseInt(v) == index) end
    ) and ((v[0] ~= nil) or (v[1] ~= nil))
end
local function userdataType(userdata)
    local typeString = tostring(userdata)
    return __TS__StringSlice(
        typeString,
        0,
        (string.find(typeString, \\":\\", nil, true) or 0) - 1
    )
end
____exports.termToString = function(v, color, level)
    if color == nil then
        color = true
    end
    if level == nil then
        level = 0
    end
    if type(v) == \\"string\\" then
        return (color and colorize.string(
            (\\"\\\\\\"\\" .. tostring(v)) .. \\"\\\\\\"\\"
        )) or v
    end
    if type(v) == \\"number\\" then
        return (color and colorize.number(v)) or tostring(v)
    end
    if type(v) == \\"boolean\\" then
        return (color and colorize.boolean(v)) or tostring(v)
    end
    if type(v) == \\"function\\" then
        return (color and colorize.number(\\"<function>\\")) or \\"<function>\\"
    end
    if v == nil then
        return (color and colorize.boolean(\\"null\\")) or \\"null\\"
    end
    if isArray(v) then
        local arr = v
        local tryingCompact = ((level + (#arr * 3)) + 2) < MAX_WIDTH
        local compact = \\"[\\" .. tostring((#arr and \\" \\") or \\"\\")
        do
            local i = 0
            while (i < #arr) and tryingCompact do
                compact = tostring(compact) .. (tostring(
                    ____exports.termToString(arr[i + 1], color, level + 1)
                ) .. tostring(((i < (#arr - 1)) and \\", \\") or \\"\\"))
                if #compact > MAX_WIDTH then
                    tryingCompact = false
                end
                i = i + 1
            end
        end
        if tryingCompact then
            compact = tostring(compact) .. (tostring((#arr and \\" \\") or \\"\\") .. \\"]\\")
            if #compact <= MAX_WIDTH then
                return compact
            end
        end
        return table.concat(
            {
                \\"[\\",
                tostring(
                    table.concat(
                        __TS__ArrayMap(
                            arr,
                            function(____, element) return tostring(
                                string.rep(
                                    INDENT,
                                    math.floor(level + 1)
                                )
                            ) .. tostring(
                                ____exports.termToString(element, color, level + 1)
                            ) end
                        ),
                        \\",\\\\n\\" or \\",\\"
                    )
                ) .. tostring((TRAILING_COMMA and \\",\\") or \\"\\"),
                tostring(
                    string.rep(
                        INDENT,
                        math.floor(level)
                    )
                ) .. \\"]\\"
            },
            \\"\\\\n\\" or \\",\\"
        )
    end
    if (type(v) == \\"table\\") and (v ~= nil) then
        local entries = __TS__ObjectEntries(v)
        local tryingCompact = (((level * INDENT_WIDTH) + (#entries * 3)) + 2) < MAX_WIDTH
        if tryingCompact then
            local compact = \\"{\\" .. tostring(((#entries > 0) and \\" \\") or \\"\\")
            do
                local i = 0
                while (i < #entries) and tryingCompact do
                    local key, value = table.unpack(entries[i + 1])
                    compact = tostring(compact) .. (((tostring(key) .. \\": \\") .. tostring(
                        ____exports.termToString(value, color, level + 1)
                    )) .. tostring(((i < (#entries - 1)) and \\", \\") or \\"\\"))
                    if ((level * INDENT_WIDTH) + #compact) > MAX_WIDTH then
                        tryingCompact = false
                    end
                    i = i + 1
                end
            end
            if tryingCompact then
                compact = tostring(compact) .. (tostring((#entries and \\" \\") or \\"\\") .. \\"}\\")
                if ((level * INDENT_WIDTH) + #compact) <= MAX_WIDTH then
                    return compact
                end
            end
        end
        return table.concat(
            {
                \\"{\\",
                tostring(
                    table.concat(
                        __TS__ArrayMap(
                            entries,
                            function(____, ____bindingPattern0)
                                local key
                                key = ____bindingPattern0[1]
                                local value
                                value = ____bindingPattern0[2]
                                local prefix = tostring(key) .. \\": \\"
                                return (tostring(
                                    string.rep(
                                        INDENT,
                                        math.floor(level + 1)
                                    )
                                ) .. tostring(prefix)) .. tostring(
                                    ____exports.termToString(value, color, level + 1)
                                )
                            end
                        ),
                        \\",\\\\n\\" or \\",\\"
                    )
                ) .. tostring((TRAILING_COMMA and \\",\\") or \\"\\"),
                tostring(
                    string.rep(
                        INDENT,
                        math.floor(level)
                    )
                ) .. \\"}\\"
            },
            \\"\\\\n\\" or \\",\\"
        )
    end
    local ____type = userdataType(v)
    local str = (\\"<\\" .. tostring(____type)) .. \\">\\"
    return (color and colorize.handle(str)) or str
end
____exports.log = function(...)
    local args = {...}
    return __TS__ArrayForEach(
        __TS__StringSplit(
            table.concat(
                __TS__ArrayMap(
                    args,
                    function(____, v) return ____exports.termToString(v) end
                ),
                \\" \\" or \\",\\"
            ),
            \\"\\\\n\\"
        ),
        function(____, line) return print(line) end
    )
end
return ____exports
end,
}
return require(\\"src.test.integration.sample\\")
"
`;
